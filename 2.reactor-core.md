# reactor-core

## 1 介绍响应式编程

作为响应式编程的第一步，微软在.net生态系统中创建了响应式扩展(reactive Extensions, Rx)库。然后RxJava在JVM上实现响应式编程。随着时间的推移，在响应流(Reactive Streams)的影响下，Java出现了一种标准化，它成为一种为JVM上的响应性库定义一组接口和交互规则的规范。它的接口已经集成到Java 9的Flow类中。

使用**迭代器**是一种命令式编程模式，即——访问值的方法完全由`Iterable`负责。这实际上是由开发人员决定何时访问序列中的`next() .item`(*因为我们基于阻塞调用，我们能够控制且能够知道程序是必定按照我们的编码来运行的*)。

在响应式流中，与上述等价的是 `Publisher-Subscriber`对儿。但是，当新值出现时，`Publisher`会通知`Subscriber` ，而这个**推送**是响应性的关键。此外，应用里，推入值的操作是**声明式**的，而不是命令式的：程序员表达的只是计算的逻辑，而不是描述其确切的控制流（*最终声明好的流程代码是在不同的线程模型中调用，它只有在最终运行的时候是确定的*）。

除了推值之外，还以具有良好的错误处理（onError）和完成处理（onComplete）定义。`Publisher`可以将新值推送到它的`Subscriber` (通过调用`onNext`)，也可以发出错误(通过调用onError)或完成(通过调用onComplete)的信号。Error和Complete都会终止序列（*即它们都是会触发终端效果*）。这可以总结如下:

> onNext x 0..N [onError | onComplete]

但是为什么我们需要这样一个异步反应性库呢?

### 1.1 阻塞可能是浪费的

现代应用程序可以接触到大量的并发用户，但即使现代硬件的能力不断提高，软件的性能仍然是一个关键问题。

一般来说，有两种方法可以提高程序的性能:

- **并行化** ：使用更多的线程和更多的硬件资源。
- 提高现有**资源的使用效率**。

通常，Java开发人员通过使用阻塞代码（*命令式*）来编写程序。在出现性能瓶颈之前，这种做法是可行的，当出现性能瓶颈之后，就引入其他线程，运行类似的阻塞代码，用来提高程序性能。但是通过这种方式扩展会很快引入（附带）竞争和并发问题。（*并行化的另一点是横向扩展，也就是我们所谓的机器集群*）

更糟糕的是，阻塞浪费了资源。如果仔细观察，一旦程序涉及一些延迟(特别是I/O，如数据库请求或网络调用)，资源就会被浪费，因为线程(可能是许多线程)现在处于空闲状态，等待数据，我们没有很好地利用这些资源。

> *并行和集群确实能够快速带来性能的提升，但事实上这并没有从根本上解决阻塞带来的 资源浪费，从另一个角度来说更多的线程在阻塞频繁的应用服务中，反而加重了资源的浪费。*如果你的应用是CPU密集型的，设计大量计算，那么使用并行化是最好的选择，它绝对不会造成资源浪费，反而在充分利用资源。如果你的应用涉及很多 IO阻塞，通常是网络IO，比方服务调用和数据库访问，那么并行化会加重资源浪费，从整体来讲它带来的性能提升不会很大，此时水平扩展反而是解决问题最有效的方法。
>
> *而且我们程序中不是所有的地方所有的代码都能够使用线程的并行化，有状态的代码通常比较难以并行化，即使可以，这对编程人员的要求也很高，正如 spring reactive 布道师 龙之春说：在座没有会使用多线程的，当然了这个世界上肯定有这样的人，但那绝对不会是你。*
>
> 当然了，有人也许会提到 类似 go 语言或者 kotlin 中的协程或者openjdk一直在孵化的 loom，这里我不能说未来是协程还是反应式的天下，在我看来，协程虽然使用起来会简单，相比反应式，但协程本身还是没有解决资源浪费的问题，因为它没有解决阻塞的问题。反应式的缺点这里不多说，在我看来，它的优点带来的价值完全有理由掩盖它的缺点，正如微服务一样，引入微服务会带来巨大的复杂性相比单体，然而依然阻挡不了它的发展。

所以**并行化**方法并不是什么灵丹妙药。它需要访问硬件的全部能力，但它也很复杂，容易造成资源浪费。

### 1.2 引入异步？

前面提到的第二种方法，**寻求更高的效率**，可以解决资源浪费问题。通过编写异步、非阻塞代码，可以让执行逻辑切换到另一个活动任务（线程），该任务使用相同的底层资源，然后在异步处理完成后返回到当前进程。

但是如何在JVM上生成异步代码呢？Java提供了两种异步编程模型:

- **Callback**:异步方法没有返回值，而是接受一个额外的`callback`参数(lambda或匿名类)，当结果可用时将调用该（函数）参数。
- **Future**: 异步方法立即返回`Future<T>`。异步进程计算T值，但是Future对象封装了对它的访问。该值不是立即可用的，对象可以轮询到该值可用为止。

这些技巧足够好吗?并不是每个用例都适用，这两种方法都有局限性。

首先：回调很难组合在一起，很快就会导致难以阅读和维护的代码(称为“回调地狱”)。

考虑一个例子:在UI上显示用户最喜欢（Favorit）的5个内容，如果用户没有最喜欢的内容，则显示该用户的推荐（suggestion）内容。它通过三个服务(一个提供最喜欢的item ids，第二个获取喜欢内容详情，第三个提供推荐详情)，如下所示:

回调地狱：

```java
// 我们有基于回调的服务:一个Callback接口，在异步流程成功时调用一个方法，在发生错误时调用一个方法。
// 1 根据userid 查询他的喜欢内容的IDS
userService.getFavorites(userId, new Callback<List<String>>() {
  // 2 调用过程没有exception，获取到最喜欢的内容IDS
  public void onSuccess(List<String> list) { 
    // 3 如果最喜欢的内容IDS 列表为空，转到 suggestionService。
    if (list.isEmpty()) { 
        // 4 suggestionService 将List<Favorite> 传递给 回调获取推荐的内容
      suggestionService.getSuggestions(new Callback<List<Favorite>>() {
        public void onSuccess(List<Favorite> list) { 
            // 因为我们处理的是UI，所以我们需要确保我们的消费代码在UI线程中运行。
          UiUtils.submitOnUiThread(() -> { 
              // 5 我们使用Java 8 Stream将处理推荐的数量限制为5个，并在UI的图形列表中显示它们。
            list.stream()
                .limit(5)
                .forEach(uiList::show); 
            });
        }
		// 6 处理错误:我们以弹出窗口显示它们。
        public void onError(Throwable error) { 
          UiUtils.errorPopup(error);
        }
      });
    } else {
        // 7 如果获取到的最喜欢内容IDS 不为空，我们需要转到favoriteService以获得详细的喜欢对象。因为我们只想要5个id，所以我们首先流化id列表，将其限制为5个。
      list.stream() 
          .limit(5)
          // 8 这次回调通过 最喜欢的id ，我们得到了一个完整的Favorite对象，我们将它推到UI线程内的UI中。
          .forEach(favId -> favoriteService.getDetails(favId, 
            new Callback<Favorite>() {
              public void onSuccess(Favorite details) {
                UiUtils.submitOnUiThread(() -> uiList.show(details));
              }

              public void onError(Throwable error) {
                UiUtils.errorPopup(error);
              }
            }
          ));
    }
  }

  public void onError(Throwable error) {
    UiUtils.errorPopup(error);
  }
}
);
```

**Reactor**改造代码：

```java
// 数据流开始于 根据userid 获取最喜欢的内容的 ids
userService.getFavorites(userId) 
    // 我们异步地将它们转换为详细的 Favorite 对象(flatMap)。我们现在有了一个Favorite详情流。
    .flatMap(favoriteService::getDetails)
    // 如果Favorite的流是空的，我们切换到suggestionService查找推荐内容。
    .switchIfEmpty(suggestionService.getSuggestions()) 
    // 我们最多只获取结果流中的5个元素
    .take(5) 
    // 最后，我们希望使用UI线程（与数据源不同的线程）处理每一条数据。
    .publishOn(UiUtils.uiThreadScheduler()) 
    // 我们通过描述如何处理数据的最终形式(在UI列表中显示它)以及在出现错误时如何处理(显示一个弹出窗口)来触发流。
    // 构造函数 第一个参数：正确结果的consumer形式，我们只进行展示，第二个参数：发生错误是的处理形式，进行弹框显示
    .subscribe(uiList::show, UiUtils::errorPopup); 
```

如果希望确保在不到800ms的时间内检索`Favorite`的 ids，或者如果需要更长的时间，从缓存获取它们，该怎么办?在基于回调的代码中，这是一项复杂的任务。在Reactor中，它变得像在链中添加一个超时操作符一样简单，如下所示:

```java
userService.getFavorites(userId)
    // 设置获取超时时间
    .timeout(Duration.ofMillis(800)) 
    // 当超时发生之后从缓存中获取最喜欢的内容
    .onErrorResume(cacheService.cachedFavoritesFor(userId)) 
    .flatMap(favoriteService::getDetails) 
    .switchIfEmpty(suggestionService.getSuggestions())
    .take(5)
    .publishOn(UiUtils.uiThreadScheduler())
    .subscribe(uiList::show, UiUtils::errorPopup);
```

了解Future的朋友可能有体验，Future对象比回调对象要好一点，但它们在组合方面仍然做得不好，尽管`CompletableFuture`在Java 8中带来了改进。将多个Future对象组合在一起是可行的，但并不容易。此外，Future还有其他问题:

- 当通过调用get()方法，还是会导致Future对象出现阻塞情况。
- 它们不支持延迟计算。
- 它们缺乏对多值（multiple values）和切面错误（advanced error）处理的支持。

考虑另一个例子:我们获得了一个ids 列表，我们想从其中获取一个name和一个statistic(统计)，并将它们成对地组合在一起，所有这些都是异步的。下面的例子是一个`CompletableFuture`类型的示例:

```java
// 1 要处理的id值列表的future
CompletableFuture<List<String>> ids = ifhIds(); 
// 2 获得id 列表后，我们希望开始一些更深入的异步处理。
CompletableFuture<List<String>> result = ids.thenComposeAsync(l -> { 
    // 3 对于列表中的每个元素:
	Stream<CompletableFuture<String>> zip = l.stream().map(i -> { 
        		// 4 异步获取相关联的name。
				CompletableFuture<String> nameTask = ifhName(i); 
        		// 5 异步获取相关联的stat。
				CompletableFuture<Integer> statTask = ifhStat(i); 
				// 6 Combine 两个 name和stat。
				return nameTask.thenCombineAsync(statTask, (name, stat) -> "Name " + name + " has stats " + stat); 
			});
    // 7 我们现在有一个Futures的列表，它表示所有的Combine任务。
	List<CompletableFuture<String>> combinationList = zip.collect(Collectors.toList()); 
    // 8 要执行这些任务，需要将列表转换为数组。
	CompletableFuture<String>[] combinationArray = combinationList.toArray(new CompletableFuture[combinationList.size()]);
	// 9 将combinationArray传递给CompletableFuture.allOf()，它输出一个Future，该Future在所有任务完成时Complet。
	CompletableFuture<Void> allDone = CompletableFuture.allOf(combinationArray); 
	return allDone.thenApply(v -> combinationList.stream()
            // 10 棘手的一点是，allOf返回CompletableFuture<Void>，所以我们在future列表上重申，通过使用join()收集它们的结果。(在这里，它不会阻塞，因为allOf确保所有的Future都完成了,我们已经得到了数据，此处已经是纯粹的数据计算了)。
			.map(CompletableFuture::join) 
			.collect(Collectors.toList()));
});

// 11 一旦整个异步管道被触发，我们就等待它被处理，并返回我们可以断言的结果列表。
// .join() 触发
List<String> results = result.join(); 
```

由于Reactor有更多的现成的组合 operators，这个过程可以简化如下:

```java
// 异步提供的id序列(Flux<String>)
Flux<String> ids = ifhrIds(); 
// 对于序列中的每个元素，我们异步处理它两次(在函数体flatMap调用内部)。
Flux<String> combinations =
		ids.flatMap(id -> { 
            // 获取相关name
			Mono<String> nameTask = ifhrName(id); 
            // 获取相关Stat
			Mono<Integer> statTask = ifhrStat(id); 
			// 异步组合两个值
			return nameTask.zipWith(statTask, 
					(name, stat) -> "Name " + name + " has stats " + stat);
		});
// 当值可用时将它们聚合到List中。
Mono<List<String>> result = combinations.collectList(); 
// 在生产中，我们将继续通过进一步合并或订阅Flux来异步地使用它。最有可能的是，我们将返回结果Mono。
// 因为我们处于测试中，所以我们将阻塞，等待处理完成，然后直接返回值的聚合列表。
List<String> results = result.block(); 
```

使用回调和Future对象的痛点类似，反应性编程用 `Publisher-Subscriber` 和大量方便的`operators`解决了这些痛点。

### 1.3 从命令式编程到反应式编程

响应式库，比如Reactor，旨在解决JVM上“经典”异步方法的这些缺点，同时还关注一些其他方面:

- 可组合性和可读性
- 数据作为一种 用丰富的operator词汇表操作的数据流
- 在你**subscribe**之前什么都不会发生，注意这一点很重要，它贯穿了整个反应式编程的基础（延迟计算）
- **Backpressure** （背压、回压）：消费者向生产者发出信号的能力——我需要多少数据流，请按需发送。

#### 可组合性和可读性

通过“可组合性”，我们指的是编排多个异步任务的能力，在这种能力中，我们使用来自前一个任务的结果来为后续任务提供输入。或者，我们可以以fork-join风格运行多个任务。此外，我们可以在更高级别的系统中作为离散组件重用异步任务。

编排任务的能力与代码的可读性和可维护性紧密耦合。随着异步流程层的数量和复杂性的增加，编写和阅读代码变得越来越困难。正如我们所看到的，回调模型很简单，但它的一个主要缺点是，对于复杂的流程，您需要从一个回调执行一个回调，它本身嵌套在另一个回调中，等等。这种混乱被称为“回调地狱”。正如您可以猜测(或从经验中知道)的那样，这样的代码是非常难以回溯和推理的。

Reactor提供了丰富的组合选项，其中代码反映了抽象过程的组织，并且所有内容通常保持在相同的级别(嵌套最小化)。

#### 装配线类比

可以将响应式应用程序处理的数据看作是在装配线上移动的数据。`reactor`既是输送带又是工作站。原材料从来源(原始**Publisher**)倾泻而出，最终成为**准备**推送给消费者(**Subscriber**)的成品。

原料可以经过各种转换和其他中间步骤，或成为更大的装配线的一部分，将中间部分聚集在一起。如果在某一点上出现了故障或堵塞(也许装箱需要相当长的时间)，受影响的工作站点可以向上游发出信号，限制原材料的流动。

#### Operators

在reactor 中，`Operators` 就是我们组装类比中的工作站。每个操作符将行为添加到Publisher，并将上一步产生的Publisher包装到一个新实例中。因此，整个过程是链接的，这样数据来源于第一个Publisher并向下移动到链中，由每个链接点进行转换。最终，**Subscriber**将完成该过程。请记住，**在Subscriber订阅Publisher之前，不会发生任何事情**，稍后我们将看到这一点。

> 也就是操作符会产生新实例。
>
> 理解这一点，可以帮助您避免一个常见的错误：您认为您在链中使用的操作符没有被应用。

虽然Reactive Streams规范根本没有指定操作符，但Reactive库(如Reactor)的最佳附加价值之一是它们提供的丰富的operator词汇表。这些内容涵盖了很多方面，从简单的转换和过滤到复杂的编排和错误处理。

#### 在`subscribe()`之前什么都不会发生

在反应器中，当您编写Publisher链时，数据默认情况下不会开始向其注入。相反，您只是了创建异步流程的抽象`描述`(*也就是声明式的*，这有助于重用性和组合)。

通过**subscribing**行为，可以将Publisher绑定到**Subscriber**，从而触发整个链中的数据流。这是通过从Subscriber在内部向上游传播的单个**request**信号实现的，该请求信号一直传播到源**Publisher**。

#### Backpressure

上游传输的信号也用于实现 Backpressure，我们在流水线类比中将其描述为：当operator的处理进程比上游工作站（发送数据的速度）慢时向上游发送的反馈（这里处理不过来了）信号。

中间操作符也可以在传输中更改请求。假设一个buffer 操作符以10个为一组对元素进行分组。如果订阅者请求一个缓冲区，则源产生十个元素是可以接受的。一些操作符还实现了预取策略，这可以避免 **request(1)** 往返。

这将推模型转换为`push-pull`混合模型，其中下游可以从上游拉出n个元素(如果它们随时可用)。但是如果这些元素还没有准备好，它们在生产的时候就会被上游推动。

#### Hot vs Cold

反应文库的Rx家族区分了两大类反应序列:热序列和冷序列。这一区别主要与响应流对订阅者的反应有关:

- 每个Subscriber都将重新启动一个Cold序列，包括在数据来源处。例如，如果源封装了一个HTTP调用，那么每个`订阅`都会发出一个新的HTTP请求。（就像我们前面一直描述的那种订阅）

  > cold直白地说就是数据流在订阅之前是不流动的，我们订阅开始接收到的数据就是它开始流动出来的数据

- Hot序列不会为每个Subscriber从头开始，它并不依赖于任何数量的订阅者，它们可以立即开始发布数据。后面的Subscriber在订阅后收到订阅之后发出的数据，reactor中的hot操作较少。然而，请注意，一些热反应流可以`缓存或回放`上游发出的全部或部分历史数据。

  > hot直白地说就是我们订阅之前它一直在发出数据，当我们订阅开始的时候接收到的数据不一定是它最开始流出的数据，我们只是接受了从我们订阅开始的数据。

关于hot/cold:[this reactor-specific section](https://projectreactor.io/docs/core/release/reference/index.html#reactor.hotCold).