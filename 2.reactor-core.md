# reactor-core

## 1 介绍响应式编程

作为响应式编程的第一步，微软在.net生态系统中创建了响应式扩展(reactive Extensions, Rx)库。然后RxJava在JVM上实现响应式编程。随着时间的推移，在响应流(Reactive Streams)的影响下，Java出现了一种标准化，它成为一种为JVM上的响应性库定义一组接口和交互规则的规范。它的接口已经集成到Java 9的Flow类中。

使用**迭代器**是一种命令式编程模式，即——访问值的方法完全由`Iterable`负责。这实际上是由开发人员决定何时访问序列中的`next() .item`(*因为我们基于阻塞调用，我们能够控制且能够知道程序是必定按照我们的编码来运行的*)。

在响应式流中，与上述等价的是 `Publisher-Subscriber`对儿。但是，当新值出现时，`Publisher`会通知`Subscriber` ，而这个**推送**是响应性的关键。此外，应用里，推入值的操作是**声明式**的，而不是命令式的：程序员表达的只是计算的逻辑，而不是描述其确切的控制流（*最终声明好的流程代码是在不同的线程模型中调用，它只有在最终运行的时候是确定的*）。

除了推值之外，还以具有良好的错误处理（onError）和完成处理（onComplete）定义。`Publisher`可以将新值推送到它的`Subscriber` (通过调用`onNext`)，也可以发出错误(通过调用onError)或完成(通过调用onComplete)的信号。Error和Complete都会终止序列（*即它们都是会触发终端效果*）。这可以总结如下:

> onNext x 0..N [onError | onComplete]

但是为什么我们需要这样一个异步反应性库呢?

### 1.1 阻塞可能是浪费的

现代应用程序可以接触到大量的并发用户，但即使现代硬件的能力不断提高，软件的性能仍然是一个关键问题。

一般来说，有两种方法可以提高程序的性能:

- **并行化** ：使用更多的线程和更多的硬件资源。
- 提高现有**资源的使用效率**。

通常，Java开发人员通过使用阻塞代码（*命令式*）来编写程序。在出现性能瓶颈之前，这种做法是可行的，当出现性能瓶颈之后，就引入其他线程，运行类似的阻塞代码，用来提高程序性能。但是通过这种方式扩展会很快引入（附带）竞争和并发问题。（*并行化的另一点是横向扩展，也就是我们所谓的机器集群*）

更糟糕的是，阻塞浪费了资源。如果仔细观察，一旦程序涉及一些延迟(特别是I/O，如数据库请求或网络调用)，资源就会被浪费，因为线程(可能是许多线程)现在处于空闲状态，等待数据，我们没有很好地利用这些资源。

> *并行和集群确实能够快速带来性能的提升，但事实上这并没有从根本上解决阻塞带来的 资源浪费，从另一个角度来说更多的线程在阻塞频繁的应用服务中，反而加重了资源的浪费。*如果你的应用是CPU密集型的，设计大量计算，那么使用并行化是最好的选择，它绝对不会造成资源浪费，反而在充分利用资源。如果你的应用涉及很多 IO阻塞，通常是网络IO，比方服务调用和数据库访问，那么并行化会加重资源浪费，从整体来讲它带来的性能提升不会很大，此时水平扩展反而是解决问题最有效的方法。
>
> *而且我们程序中不是所有的地方所有的代码都能够使用线程的并行化，有状态的代码通常比较难以并行化，即使可以，这对编程人员的要求也很高，正如 spring reactive 布道师 龙之春说：在座没有会使用多线程的，当然了这个世界上肯定有这样的人，但那绝对不会是你。*
>
> 当然了，有人也许会提到 类似 go 语言或者 kotlin 中的协程或者openjdk一直在孵化的 loom，这里我不能说未来是协程还是反应式的天下，在我看来，协程虽然使用起来会简单，相比反应式，但协程本身还是没有解决资源浪费的问题，因为它没有解决阻塞的问题。反应式的缺点这里不多说，在我看来，它的优点带来的价值完全有理由掩盖它的缺点，正如微服务一样，引入微服务会带来巨大的复杂性相比单体，然而依然阻挡不了它的发展。

所以**并行化**方法并不是什么灵丹妙药。它需要访问硬件的全部能力，但它也很复杂，容易造成资源浪费。

### 1.2 引入异步？

前面提到的第二种方法，**寻求更高的效率**，可以解决资源浪费问题。通过编写异步、非阻塞代码，可以让执行逻辑切换到另一个活动任务（线程），该任务使用相同的底层资源，然后在异步处理完成后返回到当前进程。

但是如何在JVM上生成异步代码呢？Java提供了两种异步编程模型:

- **Callback**:异步方法没有返回值，而是接受一个额外的`callback`参数(lambda或匿名类)，当结果可用时将调用该（函数）参数。
- **Future**: 异步方法立即返回`Future<T>`。异步进程计算T值，但是Future对象封装了对它的访问。该值不是立即可用的，对象可以轮询到该值可用为止。

这些技巧足够好吗?并不是每个用例都适用，这两种方法都有局限性。

首先：回调很难组合在一起，很快就会导致难以阅读和维护的代码(称为“回调地狱”)。

考虑一个例子:在UI上显示用户最喜欢（Favorit）的5个内容，如果用户没有最喜欢的内容，则显示该用户的推荐（suggestion）内容。它通过三个服务(一个提供最喜欢的item ids，第二个获取喜欢内容详情，第三个提供推荐详情)，如下所示:

回调地狱：

```java
// 我们有基于回调的服务:一个Callback接口，在异步流程成功时调用一个方法，在发生错误时调用一个方法。
// 1 根据userid 查询他的喜欢内容的IDS
userService.getFavorites(userId, new Callback<List<String>>() {
  // 2 调用过程没有exception，获取到最喜欢的内容IDS
  public void onSuccess(List<String> list) { 
    // 3 如果最喜欢的内容IDS 列表为空，转到 suggestionService。
    if (list.isEmpty()) { 
        // 4 suggestionService 将List<Favorite> 传递给 回调获取推荐的内容
      suggestionService.getSuggestions(new Callback<List<Favorite>>() {
        public void onSuccess(List<Favorite> list) { 
            // 因为我们处理的是UI，所以我们需要确保我们的消费代码在UI线程中运行。
          UiUtils.submitOnUiThread(() -> { 
              // 5 我们使用Java 8 Stream将处理推荐的数量限制为5个，并在UI的图形列表中显示它们。
            list.stream()
                .limit(5)
                .forEach(uiList::show); 
            });
        }
		// 6 处理错误:我们以弹出窗口显示它们。
        public void onError(Throwable error) { 
          UiUtils.errorPopup(error);
        }
      });
    } else {
        // 7 如果获取到的最喜欢内容IDS 不为空，我们需要转到favoriteService以获得详细的喜欢对象。因为我们只想要5个id，所以我们首先流化id列表，将其限制为5个。
      list.stream() 
          .limit(5)
          // 8 这次回调通过 最喜欢的id ，我们得到了一个完整的Favorite对象，我们将它推到UI线程内的UI中。
          .forEach(favId -> favoriteService.getDetails(favId, 
            new Callback<Favorite>() {
              public void onSuccess(Favorite details) {
                UiUtils.submitOnUiThread(() -> uiList.show(details));
              }

              public void onError(Throwable error) {
                UiUtils.errorPopup(error);
              }
            }
          ));
    }
  }

  public void onError(Throwable error) {
    UiUtils.errorPopup(error);
  }
}
);
```

**Reactor**改造代码：

```java
// 数据流开始于 根据userid 获取最喜欢的内容的 ids
userService.getFavorites(userId) 
    // 我们异步地将它们转换为详细的 Favorite 对象(flatMap)。我们现在有了一个Favorite详情流。
    .flatMap(favoriteService::getDetails)
    // 如果Favorite的流是空的，我们切换到suggestionService查找推荐内容。
    .switchIfEmpty(suggestionService.getSuggestions()) 
    // 我们最多只获取结果流中的5个元素
    .take(5) 
    // 最后，我们希望使用UI线程（与数据源不同的线程）处理每一条数据。
    .publishOn(UiUtils.uiThreadScheduler()) 
    // 我们通过描述如何处理数据的最终形式(在UI列表中显示它)以及在出现错误时如何处理(显示一个弹出窗口)来触发流。
    // 构造函数 第一个参数：正确结果的consumer形式，我们只进行展示，第二个参数：发生错误是的处理形式，进行弹框显示
    .subscribe(uiList::show, UiUtils::errorPopup); 
```

如果希望确保在不到800ms的时间内检索`Favorite`的 ids，或者如果需要更长的时间，从缓存获取它们，该怎么办?在基于回调的代码中，这是一项复杂的任务。在Reactor中，它变得像在链中添加一个超时操作符一样简单，如下所示:

```java
userService.getFavorites(userId)
    // 设置获取超时时间
    .timeout(Duration.ofMillis(800)) 
    // 当超时发生之后从缓存中获取最喜欢的内容
    .onErrorResume(cacheService.cachedFavoritesFor(userId)) 
    .flatMap(favoriteService::getDetails) 
    .switchIfEmpty(suggestionService.getSuggestions())
    .take(5)
    .publishOn(UiUtils.uiThreadScheduler())
    .subscribe(uiList::show, UiUtils::errorPopup);
```

了解Future的朋友可能有体验，Future对象比回调对象要好一点，但它们在组合方面仍然做得不好，尽管`CompletableFuture`在Java 8中带来了改进。将多个Future对象组合在一起是可行的，但并不容易。此外，Future还有其他问题:

- 当通过调用get()方法，还是会导致Future对象出现阻塞情况。
- 它们不支持延迟计算。
- 它们缺乏对多值（multiple values）和切面错误（advanced error）处理的支持。

考虑另一个例子:我们获得了一个ids 列表，我们想从其中获取一个name和一个statistic(统计)，并将它们成对地组合在一起，所有这些都是异步的。下面的例子是一个`CompletableFuture`类型的示例:

```java
// 1 要处理的id值列表的future
CompletableFuture<List<String>> ids = ifhIds(); 
// 2 获得id 列表后，我们希望开始一些更深入的异步处理。
CompletableFuture<List<String>> result = ids.thenComposeAsync(l -> { 
    // 3 对于列表中的每个元素:
	Stream<CompletableFuture<String>> zip = l.stream().map(i -> { 
        		// 4 异步获取相关联的name。
				CompletableFuture<String> nameTask = ifhName(i); 
        		// 5 异步获取相关联的stat。
				CompletableFuture<Integer> statTask = ifhStat(i); 
				// 6 Combine 两个 name和stat。
				return nameTask.thenCombineAsync(statTask, (name, stat) -> "Name " + name + " has stats " + stat); 
			});
    // 7 我们现在有一个Futures的列表，它表示所有的Combine任务。
	List<CompletableFuture<String>> combinationList = zip.collect(Collectors.toList()); 
    // 8 要执行这些任务，需要将列表转换为数组。
	CompletableFuture<String>[] combinationArray = combinationList.toArray(new CompletableFuture[combinationList.size()]);
	// 9 将combinationArray传递给CompletableFuture.allOf()，它输出一个Future，该Future在所有任务完成时Complet。
	CompletableFuture<Void> allDone = CompletableFuture.allOf(combinationArray); 
	return allDone.thenApply(v -> combinationList.stream()
            // 10 棘手的一点是，allOf返回CompletableFuture<Void>，所以我们在future列表上重申，通过使用join()收集它们的结果。(在这里，它不会阻塞，因为allOf确保所有的Future都完成了,我们已经得到了数据，此处已经是纯粹的数据计算了)。
			.map(CompletableFuture::join) 
			.collect(Collectors.toList()));
});

// 11 一旦整个异步管道被触发，我们就等待它被处理，并返回我们可以断言的结果列表。
// .join() 触发
List<String> results = result.join(); 
```

由于Reactor有更多的现成的组合 operators，这个过程可以简化如下:

```java
// 异步提供的id序列(Flux<String>)
Flux<String> ids = ifhrIds(); 
// 对于序列中的每个元素，我们异步处理它两次(在函数体flatMap调用内部)。
Flux<String> combinations =
		ids.flatMap(id -> { 
            // 获取相关name
			Mono<String> nameTask = ifhrName(id); 
            // 获取相关Stat
			Mono<Integer> statTask = ifhrStat(id); 
			// 异步组合两个值
			return nameTask.zipWith(statTask, 
					(name, stat) -> "Name " + name + " has stats " + stat);
		});
// 当值可用时将它们聚合到List中。
Mono<List<String>> result = combinations.collectList(); 
// 在生产中，我们将继续通过进一步合并或订阅Flux来异步地使用它。最有可能的是，我们将返回结果Mono。
// 因为我们处于测试中，所以我们将阻塞，等待处理完成，然后直接返回值的聚合列表。
List<String> results = result.block(); 
```

使用回调和Future对象的痛点类似，反应性编程用 `Publisher-Subscriber` 和大量方便的`operators`解决了这些痛点。

### 1.3 从命令式编程到反应式编程

响应式库，比如Reactor，旨在解决JVM上“经典”异步方法的这些缺点，同时还关注一些其他方面:

- 可组合性和可读性
- 数据作为一种 用丰富的operator词汇表操作的数据流
- 在你**subscribe**之前什么都不会发生，注意这一点很重要，它贯穿了整个反应式编程的基础（延迟计算）
- **Backpressure** （背压、回压）：消费者向生产者发出信号的能力——我需要多少数据流，请按需发送。

#### 可组合性和可读性

通过“可组合性”，我们指的是编排多个异步任务的能力，在这种能力中，我们使用来自前一个任务的结果来为后续任务提供输入。或者，我们可以以fork-join风格运行多个任务。此外，我们可以在更高级别的系统中作为离散组件重用异步任务。

编排任务的能力与代码的可读性和可维护性紧密耦合。随着异步流程层的数量和复杂性的增加，编写和阅读代码变得越来越困难。正如我们所看到的，回调模型很简单，但它的一个主要缺点是，对于复杂的流程，您需要从一个回调执行一个回调，它本身嵌套在另一个回调中，等等。这种混乱被称为“回调地狱”。正如您可以猜测(或从经验中知道)的那样，这样的代码是非常难以回溯和推理的。

Reactor提供了丰富的组合选项，其中代码反映了抽象过程的组织，并且所有内容通常保持在相同的级别(嵌套最小化)。

#### 装配线类比

可以将响应式应用程序处理的数据看作是在装配线上移动的数据。`reactor`既是输送带又是工作站。原材料从来源(原始**Publisher**)倾泻而出，最终成为**准备**推送给消费者(**Subscriber**)的成品。

原料可以经过各种转换和其他中间步骤，或成为更大的装配线的一部分，将中间部分聚集在一起。如果在某一点上出现了故障或堵塞(也许装箱需要相当长的时间)，受影响的工作站点可以向上游发出信号，限制原材料的流动。

#### Operators

在reactor 中，`Operators` 就是我们组装类比中的工作站。每个操作符将行为添加到Publisher，并将上一步产生的Publisher包装到一个新实例中。因此，整个过程是链接的，这样数据来源于第一个Publisher并向下移动到链中，由每个链接点进行转换。最终，**Subscriber**将完成该过程。请记住，**在Subscriber订阅Publisher之前，不会发生任何事情**，稍后我们将看到这一点。

> 也就是操作符会产生新实例。
>
> 理解这一点，可以帮助您避免一个常见的错误：您认为您在链中使用的操作符没有被应用。

虽然Reactive Streams规范根本没有指定操作符，但Reactive库(如Reactor)的最佳附加价值之一是它们提供的丰富的operator词汇表。这些内容涵盖了很多方面，从简单的转换和过滤到复杂的编排和错误处理。

#### 在`subscribe()`之前什么都不会发生

在反应器中，当您编写Publisher链时，数据默认情况下不会开始向其注入。相反，您只是了创建异步流程的抽象`描述`(*也就是声明式的*，这有助于重用性和组合)。

通过**subscribing**行为，可以将Publisher绑定到**Subscriber**，从而触发整个链中的数据流。这是通过从Subscriber在内部向上游传播的单个**request**信号实现的，该请求信号一直传播到源**Publisher**。

#### Backpressure

上游传输的信号也用于实现 Backpressure，我们在流水线类比中将其描述为：当operator的处理进程比上游工作站（发送数据的速度）慢时向上游发送的反馈（这里处理不过来了）信号。

中间操作符也可以在传输中更改请求。假设一个buffer 操作符以10个为一组对元素进行分组。如果订阅者请求一个缓冲区，则源产生十个元素是可以接受的。一些操作符还实现了预取策略，这可以避免 **request(1)** 往返。

这将推模型转换为`push-pull`混合模型，其中下游可以从上游拉出n个元素(如果它们随时可用)。但是如果这些元素还没有准备好，它们在生产的时候就会被上游推动。

#### Hot vs Cold

反应文库的Rx家族区分了两大类反应序列:热序列和冷序列。这一区别主要与响应流对订阅者的反应有关:

- 每个Subscriber都将重新启动一个Cold序列，包括在数据来源处。例如，如果源封装了一个HTTP调用，那么每个`订阅`都会发出一个新的HTTP请求。（就像我们前面一直描述的那种订阅）

  > cold直白地说就是数据流在订阅之前是不流动的，我们订阅开始接收到的数据就是它开始流动出来的数据

- Hot序列不会为每个Subscriber从头开始，它并不依赖于任何数量的订阅者，它们可以立即开始发布数据。后面的Subscriber在订阅后收到订阅之后发出的数据，reactor中的hot操作较少。然而，请注意，一些热反应流可以`缓存或回放`上游发出的全部或部分历史数据。

  > hot直白地说就是我们订阅之前它一直在发出数据，当我们订阅开始的时候接收到的数据不一定是它最开始流出的数据，我们只是接受了从我们订阅开始的数据。

关于hot/cold:[this reactor-specific section](https://projectreactor.io/docs/core/release/reference/index.html#reactor.hotCold).

## 2 Reactor 核心功能

Reactor项目的主要工件是Reactor-core，它是一个响应式 库，专注于响应式流规范并以Java 8为目标。

Reactor引入了实现`Publisher`的可组合反应类型，但也提供了丰富的操作词汇表:Flux和Mono。一个Flux对象表示一个反应序列0..N个项目，而Mono对象表示单个值或空(0..1)结果。

这种区别为类型提供了一些语义信息，表示异步处理的大致基数。例如，一个HTTP请求只产生一个响应，所以执行计数操作没有太大意义。因此，将这样一个HTTP调用的结果表示为`Mono<HttpResponse>`比表示为`Flux<HttpResponse>`更有意义，因为它只提供与零项或一项上下文相关的操作符。

### 2.1 `Flux`，0-N个项目的异步序列

Flux<T>是一个标准的Publisher<T>，它表示一个由0到N个发出的项组成的异步序列，可选择完成信号或错误终止。与响应流规范中一样，这三种类型的信号转换为对下Subscribe的onNext、onComplete和onError方法的调用。

请注意，所有事件，甚至是终止事件，都是可选的:没有`onNext`事件，只有`onComplete`事件表示一个空的有限序列，但是移除onComplete，您将得到一个无限的空序列(不是特别有用，除了关于取消的测试)。同样，无限序列也不一定是空的。

### 2.2 Mono，异步0-1结果

一个Mono<T>是一个专门的Publisher<T>，它最多通过onNext信号发出一个条目，然后以一个onComplete信号(成功的Mono，有或没有值)终止，或只发出一个onError信号(失败的Mono)。

大多数Mono实现都期望在调用onNext之后立即在订阅服务器上调用onComplete。Mono.never()是一个离群值:它不发出任何信号（这通常只用在测试中）。另一方面，onNext和onError的组合是显式禁止的。

请注意，您可以使用Mono来表示只有完成概念(类似于Runnable)的无值异步进程。此时可以使用 空Mono<Void>。

### 2.3 创建Flux或Mono和订阅它的简单方法

#### 创建和订阅

开始使用Flux和Mono最简单的方法是使用它们各自类中的一个工厂方法。

例如，要创建一个字符串序列，你可以枚举它们，也可以把它们放在一个集合中，然后从中创建Flux，如下所示:

```java
Flux<String> seq1 = Flux.just("foo", "bar", "foobar");

List<String> iterable = Arrays.asList("foo", "bar", "foobar");
Flux<String> seq2 = Flux.fromIterable(iterable);
```

工厂方法的其他例子包括:

```java
Mono<String> noData = Mono.empty(); 

Mono<String> data = Mono.just("foo");

Flux<Integer> numbersFromFiveToSeven = Flux.range(5, 3); 
```

在订阅方面，Flux和Mono使用了Java 8 lambdas。对于不同的回调组合，你有很多的.subscribe()变体可以选择，如下面的方法签名所示:

```java
// 订阅并触发序列。
subscribe(); 
// 为每个产生的value做一些逻辑。
subscribe(Consumer<? super T> consumer); 
// 处理值，但也会对错误作出反应。
subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer); 
// 处理值和错误，但在序列成功完成后还要运行一些代码。
subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer); 
// 处理值和错误并成功完成，但也可以使用此 subscribe 调用产生的Subscription 执行某些操作。
subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer,
          Consumer<? super Subscription> subscriptionConsumer); 
```

这些变体返回对subscribe 的引用，我们可以在不需要更多数据时使用该引用来取消订阅。 取消后，源应停止产生值并清除其创建的任何资源。

这种取消和清理行为在Reactor中由通用的Disposable接口表示。

1 简单操作

```java
// 设置一个Flux，当添加一个订阅者之后，该Flux会产生三个值。
Flux<Integer> ints = Flux.range(1, 3); 
// 以最简单的方式订阅。
ints.subscribe();
```

2 消费操作

```java
Flux<Integer> ints = Flux.range(1, 3); 
// 订阅者订阅并打印对应的value
ints.subscribe(System.out::println); 
```

3 2+error回调

```java
Flux<Integer> ints = Flux.range(1, 4)
                .map(i -> {
                    if (i <= 3) {
                        return i;
                    }
                    throw new RuntimeException("Got to 4");
                });
ints.subscribe(
		System.out::println,
		error -> System.err.println("Error: " + error)
	);
```

输出：

```java
1
2
3
Error: java.lang.RuntimeException: Got to 4
```

4 3+completion events 回调

```java
Flux<Integer> ints = Flux.range(1, 4);
ints.subscribe(
        System.out::println,
        error -> System.err.println("Error " + error),
        // 添加 completion events 处理器
        () -> System.out.println("complete Done")
);
```

输出：

```java
1
2
3
4
complete Done
```

> 注意：error 信号和complete 信号都是 终端事件（stream中的概念），并且彼此互斥。 为了使完成completion
> events 处理器工作，因此示例代码没有触发error 信号。
> complete 回调没有输入，由一对空括号表示：它与Runnable接口中的run方法匹配。

5 4+Subscription 操作

```java
Flux<Integer> ints = Flux.range(1, 4);
ints.subscribe(System.out::println,
        error -> System.err.println("Error " + error),
        () -> System.out.println("Done"),
        // 当我们订阅时，我们会收到一个 Subscription。这里表示我们要从源中获取最多10个元素（实际上将发出4个元素并完成）。
        sub -> sub.request(10));
```

> 注意，新版3.5 的api已经弃用此变种，官方的解释是使用者经常会忘记 subsciption，因此如果确实需要的话官方建议使用 subscribeWith(Subscriber) 代替。

```java
ints.subscribeWith(new Subscriber<Integer>() {
            @Override
            public void onNext(Integer integer) {
                System.out.println(integer);
            }
            @Override
            public void onError(Throwable throwable) {
                System.err.println("Error " + throwable);
            }
            @Override
            public void onComplete() {
                System.out.println("Done");
            }
            @Override
            public void onSubscribe(Subscription subscription) {
                subscription.request(10);
            }
        });
```

#### 取消`subscribe()`（Disposable）

所有这些基于lambda的subscribe()变体都有一个一次性返回类型。在这种情况下，Disposable接口表示可以通过调用其dispose()方法取消订阅。

对于Flux或Mono，取消 表示 源应该**停止产生元素**的信号。但是，它不能保证是即时的:有些源可能生成元素很快，以至于在收到**取消**指令之前就完成了。

一些关于Disposable的实用程序可以在Disposables类中找到。其中，Disposable. swap()创建了一个Disposable包装器，允许您自动取消和替换一个具体的Disposable。

另一个有趣的实用程序是disposable .composite(…)。此组合允许您收集多个Disposable——例如，多个与服务调用关联的正在处理的请求——并在稍后一次性处理所有这些请求。一旦组合的dispose()方法被调用，任何添加另一个Disposable方法的尝试都会立即处理它。

#### Lambdas的替代方案:`BaseSubscriber`

还有一个更通用的额外订阅方法，它使用一个成熟（现成的，直接可用的）的**Subscriber**，而不是用lambdas组成一个**Subscriber**。为了帮助编写这样的订阅服务器，我们提供了一个名为**BaseSubscriber**的可扩展类。

> basessubscriber的实例(或其子类)是一次性使用的，这意味着如果订阅了第二个Publisher，则basessubscriber将取消对第一个Publisher的订阅。这是因为使用实例两次将违反响应流规则，即不能并行调用Publisher的onNext方法。因此，只有在调用Publisher#subscribe(Subscriber)时直接声明匿名实现才可以。

现在我们可以实现其中一个。我们称之为samplessubscriber。下面的例子展示了如何将它附加到Flux上:

```java
SampleSubscriber<Integer> ss = new SampleSubscriber<Integer>();
Flux<Integer> ints = Flux.range(1, 4);
ints.subscribe(ss);
```

basessubscriber的一个极简实现:

```java
package io.projectreactor.samples;

import org.reactivestreams.Subscription;
import reactor.core.publisher.BaseSubscriber;

public class SampleSubscriber<T> extends BaseSubscriber<T> {

	public void hookOnSubscribe(Subscription subscription) {
		System.out.println("Subscribed");
		request(1);
	}

	public void hookOnNext(T value) {
		System.out.println(value);
		request(1);
	}
}
```

samplessubscriber类扩展了BaseSubscriber, BaseSubscriber是在Reactor中为用户定义的Subscriber推荐的抽象类。该类提供了可以被重写以调优订阅者行为的钩子。默认情况下，它会触发一个无界请求，其行为与subscribe()完全相同。然而，当你想要一个自定义的请求数量时，扩展BaseSubscriber会更有用。

对于自定义请求数量，最低限度是实现`hookOnSubscribe`和`hookOnNext`，如上面的SampleSubscriber。在我们的例子中，hookOnSubscribe方法向控制台输出一条语句并发出第一个请求。然后hookOnNext方法打印一条语句并执行额外的请求，每次一个请求。

samplessubscriber类产生以下输出:

```java
Subscribed
1
2
3
4
```

BaseSubscriber还提供了一个requestUnbounded()方法来切换到无界模式(等效于`request(Long.MAX_VALUE))`，以及一个cancel()方法。

它还有其他钩子:`hookOnComplete`、`hookOnError`、`hookOnCancel`和`hookFinally`(它总是在序列结束时被调用，终止的类型作为SignalType参数传入)

> 您几乎肯定希望实现hookOnError、hookOnCancel和hookOnComplete方法。您可能还想实现hookFinally方法。SampleSubscriber是执行有界请求的订阅服务器的绝对最小实现。

#### 背压和改造request的方法

当在Reactor中实现背压时，消费者压力传播回源的方式是通过向上游operator发送请求。当前请求的总和有时被称为当前“需求”或“待处理请求”。需求被限制在Long.MAX_VALUE，表示一个无界请求(意思是“尽可能快地生成”——基本上是禁用回压)。

第一个请求在订阅时来自最终订阅者，最直接的订阅方式默认立即触发Long.MAX_VALUE的无限制请求,比如:

- subscribe()及其大多数基于lambda的变体(具有Consumer<Subscription>的例外)
- `block()`, `blockFirst()` 和 `blockLast()`
- 在toIterable()或toStream()上迭代

定制原始请求的最简单方法是使用覆盖了hookOnSubscribe方法的basessubscriber订阅，如下面的例子所示:

```java
Flux.range(1, 10)
    .doOnRequest(r -> System.out.println("request of " + r))
    .subscribe(new BaseSubscriber<Integer>() {

      @Override
      public void hookOnSubscribe(Subscription subscription) {
        request(1);
      }

      @Override
      public void hookOnNext(Integer integer) {
        System.out.println("Cancelling after having received " + integer);
          // 只处理一个请求，然后取消订阅
        cancel();
      }
    });
```

输出：

```java
request of 1
Cancelling after having received 1
```

> 当操纵一个请求时，你必须小心地为序列产生足够的需求，否则你的Flux可能会“卡住”。这就是BaseSubscriber在`hookOnSubscribe`中默认为无界请求的原因。当重写这个钩子（`hookOnSubscribe`）时，通常应该至少调用request一次。

#### 从下游改变需求的operator

要记住的一件事是，在订阅级别表示的需求可以由上游链中的每个operator 重新调整。一个典型的例子是**buffer(N)**操作符:如果收到一个**request(2)**，它会被解释为需要两个完整的缓冲区。因此，由于缓冲区需要N个元素才能被认为是满的，buffer操作符会将请求重塑为2 x N。

您可能还注意到，有些操作符的变体接受名为prefetch的int输入参数。这是修改下游请求的另一类操作符。这些通常是处理内部序列的操作符，从每个传入元素派生出Publisher(如flatMap)。

**Prefetch** （预取）是一种调整对这些内部序列发出的初始请求的方法。如果没有指定，这些操作符大多数都初始化为32 个demand（需求）。

这些操作符通常也会实现一个补充性的优化:一旦操作符看到75%的预取请求完成，它就会从上游重新请求75%的预取请求。这是一种启发式优化，以便这些操作符能够主动预测即将到来的请求。

最后，有两个操作符可以让您直接调优请求:`limitRate`和`limitRequest`。

`limitRate(N)`对下行背压请求进行拆分，使其以较小的批数向上游请求。例如，向limitRate(10)的上游发出100个请求，最多将导致10个请求被传播到上游。注意，在这种形式中，limitRate实际上实现了前面讨论的补充优化。（限制下游的取速率）

该操作符有一个变体，可以让您调优补充量(在变体中称为lowTide): limitRate(highTide, lowTide)。选择0的lowTide会导致严格的highTide请求批处理，而不是通过补充策略进一步修改的批处理。

另一方面，`limitRequest(N)`将下游请求限制为最大总需求（一次性限制）。如果单个请求没有使总请求超过N，则该特定请求将完全向上游传播。在源发出该数量后，limitRequest认为序列已经完成，向下游发送一个onComplete信号，并取消源。

### 2.4 以编程方式创建序列

在本节中，我们将介绍如何通过编程方式定义Flux或Mono的相关事件(onNext、onError和onComplete)来创建Flux或Mono。所有这些方法都共享这样一个事实:它们公开一个API来触发我们称为**sink**的事件。

#### 同步generate

通过程序创建Flux的最简单形式是通过generate方法，该方法采用生成器函数。

这适用于同步和一个接一个（ **one-by-one**）的排放，这意味着接收器是一个SynchronousSink，并且它的next()方法在每次回调调用中最多只能被调用一次。然后，您可以另外调用error(Throwable)或complete()，但这是可选的。

最有用的变体可能是还允许您保留一个状态，以便在接收器使用中引用该状态以决定下一步发出什么。然后生成器函数变成一个BiFunction<S, SynchronousSink<T>， S>，其中<S>是状态对象的类型。你必须为初始状态提供一个Supplier<S>，你的生成器函数现在在每一轮返回一个新的状态。

例如，你可以使用int作为状态:

```java
Flux.generate(
                () -> 0,
                (state, sink) -> {
                    sink.next("3 x " + state + " = " + 3*state);
                    if (state == 10) sink.complete();
                    return state + 1;
                })
                .subscribe(System.out::println);
```

输出：

```java
3 x 0 = 0
3 x 1 = 3
3 x 2 = 6
3 x 3 = 9
3 x 4 = 12
3 x 5 = 15
3 x 6 = 18
3 x 7 = 21
3 x 8 = 24
3 x 9 = 27
3 x 10 = 30
```

您也可以使用可变的<S>。例如，上面的例子可以使用单个AtomicLong作为状态重写，在每一轮中改变它:

```java
Flux.generate(
                AtomicLong::new,
                (state, sink) -> {
                    long i = state.getAndIncrement();
                    sink.next("3 x " + i + " = " + 3*i);
                    if (i == 10) sink.complete();
                    return state;
                }).subscribe(System.out::println);
```

输出同上。

> 如果您的状态对象需要清理一些资源，请使用generate(Supplier<S>， BiFunction, Consumer<S>)变体来清理最后的状态实例。

下面的例子使用了包含Consumer的generate方法:

```java
Flux.generate(
                AtomicLong::new,
                (state, sink) -> {
                    long i = state.getAndIncrement();
                    sink.next("3 x " + i + " = " + 3*i);
                    // 当满足此条件出发下面的consumer lambda 函数
                    if (i == 5) sink.complete();
                    return state;
                },
                (state) -> System.out.println("state: " + state))
                .subscribe(System.out::println);
```

输出：

```java
3 x 0 = 0
3 x 1 = 3
3 x 2 = 6
3 x 3 = 9
3 x 4 = 12
3 x 5 = 15
state: 6
```

对于包含需要在流程结束时处理的数据库连接或其他资源的状态，Consumer lambda可以关闭连接或以其他方式处理任何应该在流程结束时完成的任务。

#### 异步多线程：create

create是一个Flux的更高级的编程创建形式，它适用于每轮的多个排放，甚至来自多个线程。

它公开一个FluxSink及其**next**、**error**和**complete**的方法。与**generate**相反，它没有基于状态的变体。另一方面，它可以在回调中触发多线程事件。

> **create对于将现有API与反应性世界连接起来非常有用——比如基于侦听器的异步API。**

> **Create既不会使代码并行化，也不会使代码异步化，**尽管它可以与异步api一起使用。如果在create lambda中阻塞，就会暴露于死锁和类似的副作用。即使使用了subscribeOn，需要注意的是，长阻塞的create lambda(例如无限循环调用sink.next(t))可以锁定管道:由于循环加载了它们应该运行的同一个线程，这些请求永远不会被执行。使用subscribeOn(Scheduler, false)变体:requestOnSeparateThread = false将使用Scheduler线程进行创建，并且仍然通过在原始线程中执行请求来让数据流动。

假设您使用一个基于侦听器的API。它通过块处理数据，有两个事件:(1)数据块已经准备好，(2)处理已经完成(终端事件)，如MyEventListener接口所示:

```java
interface MyEventListener<T> {
    void onDataChunk(List<T> chunk);
    void processComplete();
}
```

你可以使用create将其连接到Flux<T>:

```java
Flux<String> bridge = Flux.create(sink -> {
    // 每当myEventProcessor执行时，所有这些都是异步完成的。
    myEventProcessor.register( 
        // 连接到MyEventListener API
      new MyEventListener<String>() { 

        public void onDataChunk(List<String> chunk) {
          for(String s : chunk) {
              // 块中的每个元素都成为Flux中的一个元素。
            sink.next(s); 
          }
        }
		// processComplete事件被转换为onComplete。
        public void processComplete() {
            sink.complete(); 
        }
    });
});
```

此外，因为create可以桥接异步api和管理回压，你可以通过指示一个OverflowStrategy来细化如何在回压方面表现:

- **IGNORE** 完全忽略下游反压请求。当下游队列满时，这可能会产生IllegalStateException。
- ERROR 当下游无法跟上时，发出IllegalStateException信号的错误。
- DROP表示如果下游尚未准备好接收传入信号，则丢弃传入信号。
- LATEST 让下游只得到上游的最新信号。
- BUFFER (默认值)用于在下游无法跟上时缓冲所有信号。(这将进行无界缓冲，并可能导致OutOfMemoryError)。

> Mono也有一个 `create` generator。Mono创造的MonoSink不允许多种排放。它将在第一个信号之后丢弃所有信号。

#### 异步但单线程: push

Push介于generate和create之间，**适合处理来自单个生产者的事件**。它与create类似，也可以是异步的，并且可以使用create支持的任何溢出策略来管理回压。但是，每次只有一个产生线程可以调用next、complete或error。

```java
Flux<String> bridge = Flux.push(sink -> {
    myEventProcessor.register(
        // 桥接到singlethreaddeventlistener API。
      new SingleThreadEventListener<String>() { 

        public void onDataChunk(List<String> chunk) {
          for(String s : chunk) {
              // 使用next从单个侦听器线程将事件推入接收器
            sink.next(s); 
          }
        }

        public void processComplete() {
            // complete从同一侦听器线程生成的事件
            sink.complete(); 
        }

        public void processError(Throwable e) {
            // 错误事件也是由同一个侦听器线程生成的。
            sink.error(e); 
        }
    });
});
```

#### 一种混合push/pull模型

大多数reactor operator，比如create，都遵循一种推拉混合模型。我们的意思是，尽管大多数处理是异步的(建议采用push方法)，但它有一个小的拉组件: request。

consumer 从源 *pulls* 数据，因为在第一次请求之前它不会发出任何数据。当数据可用时，源将数据*push给consumer ，但在其请求的数量范围内。

请注意，push()和create()都允许设置onRequest消费者，以便管理请求数量，并确保只有在有待处理请求时才将数据推入接收。

```java
Flux<String> bridge = Flux.create(sink -> {
    myMessageProcessor.register(
      new MyMessageListener<String>() {

        public void onMessage(List<String> messages) {
          for(String s : messages) {
              // 稍后异步到达的其余消息也将被交付。
            sink.next(s); 
          }
        }
    });
    sink.onRequest(n -> {
        // 发出请求时轮询消息。
        List<String> messages = myMessageProcessor.getHistory(n); 
        for(String s : messages) {
            // 如果消息立即可用，将它们推到接收器。
           sink.next(s); 
        }
    });
});
```

#### 在push()或create()之后的清理

两个回调函数，onDispose和onCancel，在取消或终止时执行任何清理。onDispose可用于在Flux完成、出错或被取消时执行清理。onCancel可用于在onDispose清理之前执行任何特定于取消的操作。

```java
Flux<String> bridge = Flux.create(sink -> {
    sink.onRequest(n -> channel.poll(n))
        // onCancel首先被调用，仅用于取消信号。
        .onCancel(() -> channel.cancel()) 
        // 对于完全、错误或取消信号调用onDispose。
        .onDispose(() -> channel.close())  
    });
```

#### Handle

Handle方法有点不同:它是一个实例方法，这意味着它被链接到一个现有的源上(就像普通的操作符一样)。它存在于Mono和Flux中。

它接近于生成，在这个意义上，它使用一个同步接收器，并且只允许一个接一个排放。但是，句柄可以用于从每个源元素中生成任意值，可能跳过一些元素。通过这种方式，它可以作为map和filter的组合。Handle签名如下:

```java
Flux<R> handle(BiConsumer<T, SynchronousSink<R>>);
```

让我们考虑一个例子。响应式流规范禁止序列中出现空值。如果你想执行一个map映射，但你想使用一个预先存在的方法作为映射函数，而这个方法有时返回null怎么办?

例如，以下方法它可能会返回null:

```java
public String alphabet(int letterNumber) {
	if (letterNumber < 1 || letterNumber > 26) {
		return null;
	}
	int letterIndexAscii = 'A' + letterNumber - 1;
	return "" + (char) letterIndexAscii;
}
```

然后，我们可以使用handle来删除任何空值:

```java
Flux<String> alphabet = Flux.just(-1, 30, 13, 9, 20)
    .handle((i, sink) -> {
        String letter = alphabet(i); 
        if (letter != null) 
            sink.next(letter); 
    });

alphabet.subscribe(System.out::println);
```

输出：

```java
M
I
T
```

### 2.5 Threading and Schedulers

#### 概述

与RxJava一样，可以认为反应器是不依赖于并发的。也就是说，它不强制执行并发模型。相反，它让开发人员掌握主动权。但是，这并不妨碍库帮助您实现并发性。

获得Flux或Mono并不一定意味着它在专用线程中运行。相反，大多数操作符继续在前一个操作符所执行的线程中工作。除非指定，否则最顶层的操作符(源)本身在执行`subscribe()`调用的线程上运行。

而下面的例子是在一个新的线程中运行一个Mono:

```java
public static void main(String[] args) throws InterruptedException {
        // Mono<String>在线程主线程中组装。
        final Mono<String> mono = Mono.just("hello ");

        Thread t = new Thread(() -> mono
                .map(msg -> msg + "thread ")
                // 但是，它是在线程 thread-0 中订阅的。
                .subscribe(v ->
                        // 因此，map和onNext回调实际上都运行在Thread-0中
                        System.out.println(v + Thread.currentThread().getName())
                )
        );
        t.start();
        t.join();
    }
```

输出：

hello thread Thread-0

在Reactor中，执行模型和执行发生的位置由所使用的调度器决定。调度器具有类似于ExecutorService的调度职责，但是拥有专用的抽象可以让它做更多的事情，特别是充当时钟并支持更广泛的实现(用于测试的虚拟时间、即时调度，等等)。

Schedulers类具有静态方法，可以访问以下执行上下文:

- 无执行上下文(`Schedulers.immediate()`):在处理时，提交的Runnable将被直接执行，有效地在当前线程上运行它们(可以被视为一个“空对象”或无操作的Scheduler)。
- 单个可重用线程(`Schedulers.single()`)。注意，此方法为所有调用者重用同一个线程，直到Scheduler被释放。如果您想要每个调用专用线程，请为每个调用使用Schedulers.newSingle()。
- 一个无界弹性线程池(`Schedulers.elastic()`)。随着Schedulers.boundedElastic()的引入，这种方法不再受欢迎，因为它倾向于隐藏回压问题并导致太多线程(见下文)。不推荐使用。
- 有界弹性线程池(Schedulers.boundedElastic())。与它的前任elastic()一样，它根据需要创建新的工作池，并重用空闲的工作池。空闲时间过长(默认为60秒)的工作池也会被释放。与它的旧版 elastic()不同，它对可以创建的后台线程数量有一个上限(默认是CPU内核数x 10)。在达到上限后提交的多达10万个任务将排队，并将在线程可用时重新调度(如果使用延迟调度，则在线程可用时开始延迟)。这是I/O阻塞工作的更好选择。Schedulers.boundedElastic()是一种方便的方法，可以给一个阻塞的进程提供自己的线程，这样它就不会占用其他资源。
- 为并行工作而调优的固定工作池(Schedulers.parallel())。它创建的工作线程与CPU内核数量相同。

此外，您可以使用Schedulers.fromExecutorService(ExecutorService)从任何已存在的ExecutorService中创建调度程序。(您也可以从Executor创建一个，尽管不建议这样做。)

您还可以使用newXXX方法创建各种调度器类型的新实例。例如，Schedulers.newParallel(yourscheduleename)创建了一个名为yourscheduleename的new parallel scheduler。

> boundedElastic可以帮助处理遗留的阻塞代码，但是single和parallel则不能。因此，使用Reactor 阻塞api (block()， blockFirst()， blockLast()(以及迭代toIterable()或toStream())在默认的single 和parallel调度程序内)会导致抛出一个IllegalStateException。
>
> 定制Schedulers也可以通过创建实现NonBlocking标记接口的Thread实例来标记为“仅非阻塞”。

某些操作符默认情况下使用Schedulers中的特定调度器(并且通常为您提供提供不同调度器的选项)。例如，调用Flux.interval(Duration.ofMillis(300))工厂方法会生成一个Flux<Long>，每300ms执行一次。默认情况下，这是由Schedulers.parallel()启用的。下面一行将Scheduler更改为一个类似于Schedulers.single()的新实例:

```java
Flux.interval(Duration.ofMillis(300), Schedulers.newSingle("test"));
```

Reactor提供了在响应式链中切换执行上下文(或调度程序)的两种方法:publishOn和subscribeOn。两者都使用调度程序，并允许您将执行上下文切换到该调度程序。

但是publishOn在链中的位置很重要，而subscribeOn的位置则无关紧要。要理解这一区别，首先必须记住，在订阅之前什么都不会发生。

在Reactor中，当你链接操作符时，你可以根据需要将尽可能多的Flux和Mono实现打包在一起。一旦订阅，将创建一个向下(沿链向上)到第一个发布者的`Subscriber` objects链。这实际上是对你隐藏的。您所能看到的是Flux(或Mono)和Subscription的外层，但这些特定于中间operators的订阅者才是真正的工作发生的地方。

有了这些知识，我们可以更仔细地研究publishOn和subscribeOn操作符:

#### `publishOn`

publishOn的应用方式与位于subscriber 链中间的其他operators相同。它接收来自上游的信号，并在下游重放这些信号，同时从相关的Scheduler对一个worker执行回调。因此，它会影响后续operators的执行位置(直到另一个publishOn被链入)，如下所示:

- 将执行上下文更改为**Scheduler**选择的一个Thread
- 根据规范，onNext调用是依次发生的，这表明使用了单个 线程
- 除非它们在特定的Scheduler上工作，否则publishOn之后的操作符将继续在同一线程上执行

下面的例子使用了publishOn方法:

```java
// 创建一个由四个Thread实例支持的新Scheduler。
Scheduler s = Schedulers.newParallel("parallel-scheduler", 4);

final Flux<String> flux = Flux
    .just("hello", "word")
    // 第一个map在subscribe 匿名线程上运行
    .map(i -> {
        System.out.println(Thread.currentThread().getName());
        return i;
    })
    // publishOn在从 s 中选取的线程上切换整个序列。
    .publishOn(s)
    // 第二个map在 s 的线程上运行。
    .map(i -> {
        System.out.println(Thread.currentThread().getName());
        return i;
    });

// 这个匿名线程是订阅发生的地方。打印发生在最新的执行上下文中，即来自publishOn的上下文中。
new Thread(() -> flux.subscribe(System.out::println)).start();
```

输出：

```java
Thread-0
Thread-0
parallel-scheduler-1
hello
parallel-scheduler-1
word
```



![image-20210630093442227](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210630093442227.png)

> 注意“订阅之前什么都不会发生”原则，因此代码不是从上往下执行的，是从subscribe开始逆向运作的。

#### `subscribeOn`

当 倒链（backward chain）被构造时，subscribeOn应用于订阅处理。因此，无论您将subscribeOn放置在链中的哪个位置，它总是会影响源发射的上下文。但是，这并不影响后续调用publishOn的行为——它们仍然为后面的链部分切换执行上下文。

- 更改整个operators 链所订阅的线程
- 从Scheduler中选择一个线程

> 实际上只考虑链中最早的subscribeOn调用。

下面的例子使用了subscribeOn方法:

```java
// 创建一个由四个Thread支持的新Scheduler。
Scheduler s = Schedulers.newParallel("parallel-scheduler", 4);

final Flux<String> flux = Flux
    .just("hello", "word")
    // 第一个 map 运行在Scheduler四个线程中的一个上……
    .map(i -> {
        System.out.println(Thread.currentThread().getName());
        return i;
    })
    // 因为subscribeOn将整个序列从subscribe时间右切换。
    .subscribeOn(s)
    // 第二个map也在同一个线程上运行。
    .map(i -> {
        System.out.println(Thread.currentThread().getName());
        return i;
    });
// 这个匿名线程是订阅最初发生的地方，但subscribeOn立即将其转移到四个调度程序线程之一。
// 也就是说 subscribeOn 取代subscribe 成了第二个开始的地方
new Thread(() -> flux.subscribe(System.out::println)).start();
```

输出：

```java
parallel-scheduler-1
parallel-scheduler-1
hello
parallel-scheduler-1
parallel-scheduler-1
word
```

### 2.6 Handling Errors

#### 概述

在响应流中，错误是终端事件。一旦发生错误，它就停止序列，并沿操作符链向下传播到最后一步，即您定义的订阅服务器及其onError方法。

此类错误仍应在应用程序级别处理。例如，您可以在UI中显示错误通知，或者在REST端点中发送有意义的错误 payload。因此，应该始终定义subscriber’s 的`onError`方法。

> 如果未定义，onError抛出UnsupportedOperationException。您可以使用Exceptions进一步检测和分类Exception.isErrorCallbackNotImplemented方法。

Reactor还提供了在链的中间处理错误的替代方法，如错误处理操作符。下面的例子展示了如何做到这一点:

```java
Flux.just(1, 0, 2)
                .map(i -> "100 / " + i + " = " + (100 / i)) // 0的时候触发错误
                .onErrorReturn("Divided by zero :(") // error 处理
                .subscribe(System.out::println);
```

输出：

```java
100 / 1 = 100
Divided by zero :(
```

可见当发生错误的时候序列结束（2 没有被输出，即使使用了错误处理操作符），直接输出了错误信息。

> 在学习错误处理操作符之前，必须记住**反应序列中的任何错误都是终端事件**。即使使用了错误处理操作符，它也不会让原始序列继续。相反，它将onError信号转换为一个新序列(回退序列)的开始。换句话说，它取代了上游终止的序列。

#### Error Handling Operators

您可能熟悉几种在try-catch块中处理异常的方法。最值得注意的是，这些包括:

- 捕获并返回一个静态默认值。
- 使用回退方法捕获并执行一个替代的路径。
- 捕获并动态计算回退值。
- 捕获、包装到BusinessException，并重新抛出。
- 捕获，记录特定于错误的消息，并重新抛出。
- 使用finally块来清理资源或Java 7的“try-with-resource”构造。

所有这些在Reactor中都有等价的东西，以错误处理操作符的形式存在。

在订阅时，链末端的onError回调类似于catch块。在那里，如果抛出一个Exception，执行会跳到捕获，如下面的例子所示:

```java
Flux<String> s = Flux.range(1, 10)
    	// 将执行可能引发异常的转换。
        .map(v -> doSomethingDangerous(v))
    	// 如果一切顺利，将执行第二次转换。
        .map(v -> doSecondTransform(v));
		// 每个成功转换的值都会被打印出来。
        s.subscribe(value -> System.out.println("RECEIVED " + value),
                    // 如果出现错误，序列将终止并显示错误消息。
                    // onError回调，类似于catch块
                    error -> System.err.println("CAUGHT " + error)
        );
```

上面的例子在概念上类似于下面的try-catch块:

```java
try {
    for (int i = 1; i < 11; i++) {
        String v1 = doSomethingDangerous(i); 
        String v2 = doSecondTransform(v1); 
        System.out.println("RECEIVED " + v2);
    }
} catch (Throwable t) {
    System.err.println("CAUGHT " + t); 
}
```

##### Static Fallback Value

对应 的操作符：onErrorReturn。下面的例子展示了如何使用它:

```java
try {
  return doSomethingDangerous(10);
}
catch (Throwable error) {
  return "RECOVERED";
}
```

operators：

```java
Flux.just(10)
    .map(this::doSomethingDangerous)
    // 返回静态值
    .onErrorReturn("RECOVERED");
```

您还可以选择对异常应用Predicate（判断）来决定是否恢复，如下面的示例所示:

```java
Flux.just(10)
    .map(this::doSomethingDangerous)
    // 谓词构造函数
    .onErrorReturn(e -> e.getMessage().equals("boom10"), "recovered10"); 
```

##### Fallback Method

如果您想要多个默认值，并且有另一种(更安全的)处理数据的方法，则可以使用onErrorResume。这相当于“使用回退方法捕获并执行一个替代的路径”。

需求：我们调用一个外部api获取数据，如果获取外部失败啊，从缓存获取设置值。

```java
String v1;
try {
  v1 = callExternalService("key1");
}
catch (Throwable error) {
  v1 = getFromCache("key1");
}

String v2;
try {
  v2 = callExternalService("key2");
}
catch (Throwable error) {
  v2 = getFromCache("key2");
}
```

Reactor 示例：

```java
Flux.just("key1", "key2")
    // 对于每个key，异步调用外部服务。如果外部服务调用失败，(onErrorResume)返回该key的Cache(getFromCache)。请注意，无论源错误e是什么，我们总是应用相同的fallbakc处理。
    .flatMap(k -> callExternalService(k).onErrorResume(e -> getFromCache(k)));
```

与onErrorReturn一样，onErrorResume也有一些变体，让您可以根据异常的类或判断条件来筛选返回的异常。它可以接受函数，因此允许您根据所遇到的错误选择不同的fallback序列。下面的例子展示了如何做到这一点:

```java
Flux.just("timeout1", "unknown", "key2")
    .flatMap(k -> callExternalService(k)
        // 该函数允许动态选择如何继续
        .onErrorResume(error -> { 
            // 如果source 超时，使用缓存
            if (error instanceof TimeoutException) 
                return getFromCache(k);
            // 如果消息来源说UnknownKey，就创建一个新条目
            else if (error instanceof UnknownKeyException)  
                return registerNewEntry(k, "DEFAULT");
            // 在所有其他情况下，再次将错误抛出
            else
                return Flux.error(error); 
        })
    );
```

##### Dynamic Fallback Value

即使您没有另一种(更安全的)处理数据的方法，您也可能希望从接收到的异常中计算回退值。这相当于“捕获并动态计算回退值”。

例如，如果您的返回类型(MyWrapper)有一个用于保存异常的变体(想想Future.complete(T success)和future . completeexceptions (Throwable error))，您可以实例化保存错误的变体并传递异常。

一个命令式示例如下所示:

```java
try {
  Value v = erroringMethod();
  return MyWrapper.fromValue(v);
}
catch (Throwable error) {
  return MyWrapper.fromError(error);
}
```

你可以像回退方法解决方案一样，通过使用onErrorResume和一些样板文件，如下所示:

```java
// 因为您希望用MyWrapper表示错误，所以需要为onErrorResume获得Mono<MyWrapper>。我们使用Mono.just()。
erroringFlux.onErrorResume(error -> Mono.just(
    	// 我们需要从异常中计算出值。在这里，我们通过使用相关的MyWrapper工厂方法包装异常来实现这一点。
        MyWrapper.fromError(error) 
));
```

##### Catch and Rethrow(捕捉再次抛出)

就想下面的：

```java
try {
  return callExternalService(k);
}
catch (Throwable error) {
  throw new BusinessException("oops, SLA exceeded", error);
}
```

Reacor:

```java
Flux.just("timeout1")
    .flatMap(k -> callExternalService(k))
    // 捕获重新包装抛出
    .onErrorResume(original -> Flux.error(
            new BusinessException("oops, SLA exceeded", original))
    );
```

然而，有一种更直接的方法可以用onErrorMap实现相同的效果:

```java
Flux.just("timeout1")
    .flatMap(k -> callExternalService(k))
    .onErrorMap(original -> new BusinessException("oops, SLA exceeded", original));
```

##### Log or React on the Side

对于希望错误继续传播，但仍然希望在不修改序列(例如记录它)的情况下对其作出反应的情况，可以使用doOnError操作符。这相当于“捕获，记录特定于错误的消息，然后重新抛出”模式，如下面的示例所示:

```java
try {
  return callExternalService(k);
}
catch (RuntimeException error) {
  //make a record of the error
  log("uh oh, falling back, service failed for key " + k);
  throw error;
}
```

doOnError操作符，以及所有以doOn为前缀的操作符，有时被称为具有“副作用”。它们允许您在不修改的情况下窥视序列的事件内部。

与前面显示的命令式示例一样，下面的示例仍然传播错误，但确保我们至少记录外部服务有一个失败:

```java
LongAdder failureStat = new LongAdder();
Flux<String> flux =
Flux.just("unknown")
    // 可能失败的外部服务调用…
    .flatMap(k -> callExternalService(k) 
        .doOnError(e -> {
            failureStat.increment();
            // 带有日志记录和统计的副作用…
            log("uh oh, falling back, service failed for key " + k); 
        })
        // 在此之后，它仍然以错误结束，除非我们在这里使用错误恢复操作符。
    );
```

##### Using Resources and the Finally Block

命令式编程的最后一个并行操作是清理，可以通过使用“Use of The finally block to clean resources”或使用“Java 7 try-with-resource construct”来完成，如下所示:

就像：

```java
Stats stats = new Stats();
stats.startTimer();
try {
  doSomethingDangerous();
}
finally {
  stats.stopTimerAndRecordTiming();
}
```

java-7的便捷写法

```java
try (SomeAutoCloseable disposableInstance = new SomeAutoCloseable()) {
  return disposableInstance.toString();
}
```

两者都有它们的reactor 操作符:`doFinally`和`using`。

doFinally是关于当序列终止(带有onComplete或onError)或被取消时想要执行的副作用。

```java
Stats stats = new Stats();
LongAdder statsCancel = new LongAdder();

Flux<String> flux =
Flux.just("foo", "bar")
    .doOnSubscribe(s -> stats.startTimer())
    // doFinally使用SignalType作为终止类型。
    .doFinally(type -> { 
        // 与finally块类似，我们总是记录计时。
        stats.stopTimerAndRecordTiming();
        // 在这里，我们还只在取消的情况下增加统计信息
        if (type == SignalType.CANCEL) 
          statsCancel.increment();
    })
    // Take(1)在一个项目发出后取消。
    .take(1); 
```

另一方面，使用可以处理这样的情况，即Flux是从资源中派生出来的，并且在处理完成时必须对该资源进行操作。在下面的例子中，我们用Disposable替换了" try-with-resource "的AutoCloseable接口:

```java
AtomicBoolean isDisposed = new AtomicBoolean();
Disposable disposableInstance = new Disposable() {
    @Override
    public void dispose() {
        // 4 在订阅和执行序列之后，isdispose原子布尔值变为true。
        isDisposed.set(true); 
    }

    @Override
    public String toString() {
        return "DISPOSABLE";
    }
};
```

现在，我们可以对它执行类似于“try-with-resource”的响应式操作，如下所示:

```java
Flux<String> flux =
Flux.using(
    	// 1 第一个lambda生成资源。这里，我们返回mock Disposable。
        () -> disposableInstance, 
    	// 2 第二个lambda处理资源，返回一个Flux<T>。
        disposable -> Flux.just(disposable.toString()), 
    	// 3 第二个的Flux终止或被取消时，将调用第三个lambda来清理资源
        Disposable::dispose 
);
```

##### 演示onError的终端方面

为了演示所有这些操作符导致在错误发生时终止上游原始序列，我们可以使用一个更直观的示例，其中包含Flux.interval。区间运算符在每x个单位的时间中标记一个增加的Long值。下面的例子使用了一个区间运算符:

```java
Flux<String> flux =
Flux.interval(Duration.ofMillis(250))
    .map(input -> {
        if (input < 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .onErrorReturn("Uh oh");

flux.subscribe(System.out::println);
Thread.sleep(2100); 
```

> 注意，默认情况下，interval在**timer** `Scheduler` 上执行。如果我们想在主类中运行例子，我们需要在这里添加一个sleep调用，这样应用程序不会在没有产生任何值的情况下立即退出。

输出：

```java
tick 0
tick 1
tick 2
Uh oh
```

即使有额外的一秒运行时间，也不会有更多的数据从间隔中进来。这个序列确实被错误终止了。

##### Retrying

还有另一个与错误处理有关的操作符，您可能会在上一节描述的情况中使用它。顾名思义，重试允许您重试产生错误的序列。

要记住的是，它是通过重新订阅(**re-subscribing** )上游Flux来工作的。这真的是一个不同的序列，最初的那个仍然被终止了。为了验证这一点，我们可以重用前面的示例，并添加重试(1)来重试一次，而不是使用onErrorReturn。下面的例子展示了如何做sl:

```java
Flux.interval(Duration.ofMillis(250))
    .map(input -> {
        if (input < 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .retry(1)
    // 将每个值与前一个值发出后的持续时间相关联
    .elapsed()
    .subscribe(System.out::println, 
               // 输出error
               System.err::println);

// 确保我们有足够的时间进行数据生产。
Thread.sleep(2100);
```

输出：

```java
[254,tick 0]
[250,tick 1]
[250,tick 2]
[507,tick 0]
[250,tick 1]
[250,tick 2]
java.lang.RuntimeException: boom
```

重试有一个更高级的版本(称为retryWhen)，它使用“伴生”Flux来判断某个特定的失败是否应该重试。这个伴随的Flux由operator创建，但由用户装饰，以便自定义重试条件。（**核心是能够通过一个函数控制重试逻辑**）

伴随的Flux是一个Flux< retrsignal >，它被传递给重试策略/函数，作为retryWhen的唯一参数提供。作为用户，定义该函数并让它返回一个新的Publisher<?>。Retry类是一个抽象类，但如果您想转换与简单lambda 伴随的对象，则它提供了一个工厂方法(Retry.from(Function))。

重试周期如下:

- 每次发生错误(提供了重试的可能性)时，一个retrsignal被发射到伴随的Flux中，它已经被您的函数修饰过了。在这里有一个Flux可以鸟瞰到目前为止的所有尝试。retrsignal提供了对错误以及围绕错误的元数据的访问。
- 如果伴随Flux发出一个值，就会发生重试。
- 如果伴随的Flux完成，错误将被排除，重试周期将停止，产生的序列也将完成。
- 如果伴随的Flux产生一个错误(e)，重试周期停止，产生的序列错误为e。

前两种情况之间的区别很重要。考虑以下使用retryWhen模拟**retry(3)**的方法:

```java
Flux<String> flux = Flux
    // 这将不断产生错误，并调用重试尝试。
    .<String>error(new IllegalArgumentException()) 
    // 重试之前的doOnError让我们记录并查看所有失败。
    .doOnError(System.out::println) 
    // Retry适配于一个非常简单的Function lambda
    .retryWhen(Retry.from(companion -> 
        // 在这里，我们认为前三个错误是可以重试的(接受(3))，超过之后直接放弃。
        companion.take(3))
    ); 
```

实际上，上面的示例最后得到一个空的Flux（而不是null），也就是说它最后成功地完成了。由于同一Flux上的`retry(3)`会以最新的错误终止，所以这个retryWhen示例与`retry(3)`并不完全相同（将上面的retryWhen 换为retry最终将会抛出java.lang.IllegalArgumentException 错误，并终止序列，而不是完成，读者可以尝试代码测试）。

要达到同样的行为（和retry）还需要一些额外的技巧:

```java
Flux.<String>error(new IllegalArgumentException())
    .doOnError(System.out::println)
    // 我们通过自定义Function lambda来定制Retry
    .retryWhen(Retry.from(companion ->
                          // companion 发出retrsignal对象，其中包含到目前为止的重试次数和最后一次失败
                          companion.map(rs -> {
                              // 为了允许三次重试，我们考虑totalRetries索引< 3并返回一个要发出的值(这里我们只返回索引)。
                              if (rs.totalRetries() < 3) return rs.totalRetries();
                              // 为了终止错误中的序列，我们在这三次重试之后抛出原始异常。
                              else throw Exceptions.propagate(rs.failure());
                          })
                         )).subscribe(System.out::println);
```

> 可以使用在Retry中公开的构建器以更流畅的方式实现相同的目标，以及更精细地调整重试策略。例如:errorFlux.retryWhen (Retry.max(3));。

核心提供的重试帮助程序，RetrySpec和RetryBackoffSpec，都允许高级定制，如:

- 为可能触发重试的异常设置**filter(Predicate)**
- 通过**modifyErrorFilter(Function)**修改之前设置的过滤器
- 触发一个副作用，比如在重试触发器周围记录日志(即在延迟之前和之后的回退)，只要重试是有效的(doBeforeRetry()和doAfterRetry()是附加的)
- 触发一个异步Mono<Void>环绕重试触发器，它允许在基础延迟之上添加异步行为，但因此进一步延迟触发器(dobeforeeretryasync和doAfterRetryAsync是添加的)
- 通过**onRetryExhaustedThrow(BiFunction)**定制达到最大尝试次数的异常。默认情况下，使用Exceptions.retryExhausted(…)，可以通过Exceptions.isRetryExhausted(Throwable)来区分。
- 激活瞬态错误的处理(见下面)

Retry规范中的**瞬时错误**处理使用了`retrsignal #totalRetriesInARow()`:来检查是否重试，并计算重试延迟，使用的索引是一个替代索引，每次触发onNext时该索引将重置为0。这样做的后果是，如果重新订阅的源在再次失败之前生成了一些数据，那么以前的失败不计入重试尝试的最大次数。在指数回退策略中，这也意味着下一次尝试将使用最小持续时间回退，而不是更长的时间回退。这对于看到零星错误突发(或瞬态错误)的长寿命源尤其有用，在这种情况下，每个突发都应该用自己的回退来重试。

```java
// 我们将计算重试序列中的错误数。
AtomicInteger errorCount = new AtomicInteger();
AtomicInteger transientHelper = new AtomicInteger();
Flux<Integer> transientFlux = Flux.<Integer>generate(sink -> {
    int i = transientHelper.getAndIncrement();
    // 我们产生一个会有错误爆发的源。当计数器达到10时，它将complete。
    if (i == 10) {
        sink.next(i);
        sink.complete();
    }
    // 如果transientHelper是3的倍数，我们进行 onNext。
    else if (i % 3 == 0) {
        sink.next(i);
    }
    else {
        // 在其他情况下，我们发出onError。那是3次中的2次，所以2个onError被1个onNext中断。
        // 也就是 0 3 6 9 被跳过了  会偶发 6次错误
        sink.error(new IllegalStateException("Transient error at " + i));
    }
}).doOnError(e -> {
    errorCount.incrementAndGet();
    System.out.println(e);
});
// 在transientErrors模式下,我们在该源上使用retryWhen，它被配置为最多2次重试尝试。
// 设置瞬时错误模式，表示正在构建的策略应该使用 Retry.RetrySignal#totalRetriesInARow(),而不是 Retry.RetrySignal#totalRetries()，瞬态错误是可能在突发中发生的错误，但在另一个错误发生之前通过重试（使用一个或多个 onNext 信号）将其恢复。（以防止中断整个序列）
transientFlux.retryWhen(Retry.max(2).transientErrors(true))
    .blockLast();
// 最后，在errorCount中注册了6个错误之后，序列到达onNext(10)并完成。
System.out.println(errorCount.intValue() == 6);
```

如果没有`transientErrors(true)`，第二个突发将达到配置的最大尝试2，并且序列在发出onNext(3)之后将失败。(0,3已经触发了两次重试，第三次将中断序列)

输出：

```java
java.lang.IllegalStateException: Transient error at 1
java.lang.IllegalStateException: Transient error at 2
java.lang.IllegalStateException: Transient error at 4
Exception in thread "main" reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 2/2
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:290)

```

##### 处理operator或function中的异常

一般来说，所有操作符本身都可以包含可能触发异常或对用户定义回调的调用的代码，这些代码同样可能失败，因此它们都包含某种形式的错误处理。

根据经验，未经检查的异常总是通过onError传播。例如，在map函数中抛出RuntimeException会转化为onError事件，如下代码所示:

```java
Flux.just("foo")
    .map(s -> { throw new IllegalArgumentException(s); })
    .subscribe(v -> System.out.println("GOT VALUE"),
               e -> System.out.println("ERROR: " + e));
```

输出：

```java
ERROR: java.lang.IllegalArgumentException: foo
```

> 通过使用钩子，可以在将Exception传递给onError之前对其进行调优。

然而，Reactor定义了一组总是被认为是致命的异常(如OutOfMemoryError)。看到`Exceptions.throwIfFata`方法。这些错误意味着反应器不能继续运行，并被抛出而不是传播。

> 在内部，由于并发竞争可能导致双重的onError或onComplete条件，还存在无法传播未检查异常的情况(最明显的是在订阅和请求阶段)。当这些竞争发生时，无法传播的错误将被“删除”。在某种程度上，这些情况仍然可以通过使用可定制的钩子来管理。

您可能会问:“那么受检异常呢?”

例如，如果需要调用某个方法声明它抛出异常，则仍然必须在try-catch块中处理这些异常。不过，你有几个选择:

- 捕获异常并从中恢复。序列正常继续。
- 捕获异常，将其包装为非受检异常，然后抛出它(中断序列)。Exceptions实用程序类可以帮助您实现这一点
- 如果你需要返回一个Flux(例如，你在一个flatMap中)，将异常包装在一个产生错误的Flux中，如下所示:return Flux.error(checkedException)。(该序列也会终止。)

Reactor有一个Exceptions实用程序类，你可以使用它来确保只有当它们是受检异常时才会被包装:

- 使用**Exceptions.propagate**来包装异常。它还首先调用throwIfFatal，不包装RuntimeException。
- 使用**Exceptions.unwrap**方法获取原始的未包装异常(回到特定于反应堆的异常层次结构的根本原因)。

考虑下面例子:

```java
public String convert(int i) throws IOException {
    if (i > 3) {
        throw new IOException("boom " + i);
    }
    return "OK " + i;
}
```

现在假设您想在map中使用该方法。您现在必须显式地捕获异常，并且您的map函数不能重新抛出它。所以你可以将它作为RuntimeException传播到map的onError方法，如下所示:

```java
Flux
    .range(1, 10)
    .map(i -> {
        try {
            return convert(i);
        }
        catch (IOException e) {
            // 最后会传播到 onError
            throw Exceptions.propagate(e);
        }
    }).subscribe(System.out::println,
                 System.out::println);
```

输出：
OK 1
OK 2
OK 3
java.io.IOException: boom 4

稍后，当订阅前面的Flux并对错误做出反应(比如在UI中)时，如果你想对ioexception做一些特殊的事情，你可以回到最初的异常。下面的例子展示了如何做到这一点:

```java
Flux
    .range(1, 10)
    .map(i -> {
        try {
            return convert(i);
        }
        catch (IOException e) {
            throw Exceptions.propagate(e);
        }
    }).subscribe(
    // 正常consume
    v -> System.out.println("RECEIVED: " + v),
    // onError
    e -> {
        if (Exceptions.unwrap(e) instanceof IOException) {
            System.out.println("Something bad happened with I/O");
        } else {
            System.out.println("Something bad happened");
        }
    }
);
```

输出：

RECEIVED: OK 1
RECEIVED: OK 2
RECEIVED: OK 3
Something bad happened with I/O

------



### 2.7 Processors and Sinks

#### 概述

Processor是一种特殊的Publisher，也是 `Subscriber`。它们最初的目的是作为一个中间步骤的可能表示，然后可以在Reactive Streams实现之间共享。然而，在Reactor中，这些步骤是由Publisher之类的操作符表示的。

一次遇到Processor时，一个常见的错误是试图直接从**Subscriber**接口调用公开的onNext、onComplete和onError方法。

这样的手动调用应该小心进行，特别是在响应流规范的调用的外部同步方面。处理器实际上可能略微有用，除非遇到需要传递**Subscriber**而不是公开Publisher的基于响应流的API。

Sinks 通常是更好的选择。在反应堆中，Sink是一个允许安全手动触发信号的类。它可以与订阅关联(从操作符内部)，也可以完全独立。

从3.4.0开始，sink成为了头等公民，Processor被完全淘汰:

- 抽象和具体的FluxProcessor和MonoProcessor都已弃用，并将在3.5.0中移除
- 不是由操作符产生的sink是通过sink类中的工厂方法构造的。
- 我们希望所有的Processor用法都可以替换为现有的操作符或来自sink的新接收器。

#### 通过使用`Sinks.One` /`Sinks.Many` 安全地从多个线程中生产

sink构建器为主要支持的生产者类型提供了一个指导API。您将在Flux中发现一些行为，比如onBackpressureBuffer。

```java
Sinks.Many<Integer> replaySink = Sinks.many().replay().all();
```

多个producer线程可以通过执行以下操作并发地在接收器上生成数据:

```java
//thread1
sink.emitNext(1, Sinks.EmitFailureHandler.FAIL_FAST);

//thread2
sink.emitNext(2, Sinks.EmitFailureHandler.FAIL_FAST);

//thread3, 与 thread 2 并发
Sinks.EmitResult result = sink.tryEmitNext(3); //会 return FAIL_NON_SERIALIZED
```

Sinks.Many 可以作为Flux呈现给下游消费者，如下面的例子:

```java
Flux<Integer> fluxView = replaySink.asFlux();
fluxView
        .takeWhile(i -> i < 10)
        .log()
        .blockLast();
```

同样,Sinks.Empty和**Sinks.One**可以使用asMono()方法转换为Mono。

Sinks 类别是:

1. `many().multicast()`: 一个只向其订阅者传输新推送数据的接收器，以满足他们的背压(新推送的意思是“在订阅者订阅之后”)。
2. `many().unicast()`:  与上面一样，只是在第一个订阅者注册之前推送的数据会被缓冲。
3. `many().replay()`: 一个接收器，它将向新订阅者重放指定的推送数据的历史大小，然后继续实时推送新数据。
4. `one()`: 将向其订阅者播放单个元素的接收器
5. `empty()`:  一个接收器，它将只向其订阅者播放终端信号(错误或完整)，但仍然可以视为Mono<T>

#### 可用Sinks概览

##### Sinks.many().unicast().onBackpressureBuffer(args?)

一个单播**Sinks.Many**可以通过使用内部缓冲区来处理背压。折衷之处是它最多可以拥有一个**Subscriber**。

基本的unicast Sink 是通过sink .many().unicast(). onbackpressurebuffer()创建的。但是在sink .many().unicast()中有一些额外的unicast静态工厂方法允许更精细的调优。

例如，默认情况下，它是无界的:如果在Subscriber尚未请求数据时将任何数量的数据压入它，它将缓冲所有数据。可以通过在sink .many().unicast().onbackpressurebuffer(Queue)工厂方法中为内部缓冲提供自定义Queue实现来改变这一点。如果该队列是有限制的，那么当缓冲区已满且没有从下游接收到足够的请求时，接收器可以拒绝推送值。

##### Sinks.many().multicast().onBackpressureBuffer(args?)

一个多播Sinks.Many可以发送给多个订阅者，同时给每个订阅者带来背压。订阅者只接收**订阅后**通过接收器推送的信号。

基本的多播接收器是通过sink .many().multicast().onbackpressurebuffer()创建的。

默认情况下，如果它的所有订阅者都被取消(这基本上意味着它们都未订阅)，它将清除其内部缓冲区并停止接受新的订阅者。您可以通过使用sink .many().multicast()下的组播静态工厂方法中的autoCancel参数来调优此参数。

##### Sinks.many().multicast().directAllOrNothing()

一个多播**Sinks.Many**对反压力的处理过于简单:如果任何订阅者太慢(需求为零)，onNext将为所有订阅者删除。

然而，慢速订阅者不会被终止，一旦慢速订阅者再次开始请求，所有的接收元素都将从那里继续推送。

一旦**Sinks.Many**已经终止了(通常通过调用它的emitError(Throwable)或emitComplete()方法)，它允许更多的订阅者订阅，但会立即向他们重放终止信号。

##### Sinks.many().multicast().directBestEffort()

一个多播 `Sinks.Many`尽最大努力处理背压:如果一个订阅者太慢(没有需求)，onNext只会为这个慢的订阅者删除。

然而，慢速订阅者不会被终止，一旦他们再次开始请求，他们将恢复接收新推送的元素。

一旦 `Sinks.Many`已经终止了(通常通过调用它的emitError(Throwable)或emitComplete()方法)，它允许更多的订阅者订阅，但会立即向他们重放终止信号。

#####  Sinks.many().replay()

replay **Sinks.Many**缓存发出的元素，并将它们重放给迟延的订阅者。

它可以在多种配置中创建:

​	缓存一个有限的历史记录(sink .many().replay().limit(int))或一个无界的历史记录(sink .many().replay().all())。

​	缓存基于时间的重放窗口(sink .many().replay().limit(Duration))。

​	同时缓存历史记录大小和时间窗口(**Sinks.many().replay().limit(int, Duration)**)。

在sink .many().replay()以及允许缓存单个元素(latest()和latestOrDefault(T))的变体中，还可以找到用于上述微调的额外重载。

##### Sinks.unsafe().many()

高级用户和operators builders 可能想要考虑使用sink.unsafe().many()，它将提供相同的 `Sinks.Many` 工厂没有额外的生产者线程安全。因此，每个接收器的开销会更少，因为线程安全的接收器必须检测多线程访问。

库开发人员不应该公开不安全的接收器，但可以在受控的调用环境中内部使用它们，在这种环境中，他们可以确保导致onNext、onComplete和onError信号的调用的外部同步，这与Reactive Streams规范有关。

##### Sinks.one()

这个方法直接构造了一个简单的sink . one <T>的实例。这种风格的sink可以看作是一个Mono(通过它的asMono()视图方法)，并且有略微不同的emit方法来更好地传达这种类似Mono的语义:

​	emitValue(T **value**)生成一个onNext(值)信号，在大多数实现中，也会触发一个隐式的onComplete()

​	emitEmpty()生成一个隔离的onComplete()信号，目的是生成一个空的Mono

​	emitError(Throwable t)生成一个onError(t)信号

sink .one()接受这些方法中的任何一个调用，有效地生成一个Mono，该Mono要么完成一个值，要么完成为空，要么失败。

##### Sinks.empty()

这个方法直接构造了一个简单的sink . empty <T>的实例。这个**Sinks**的就像**Sinks.One<T>**，但它不提供emitValue方法。

因此，它只能生成一个完成为空或失败的Mono。

尽管无法触发onNext，接收器仍然使用泛型<T>类型，因为它允许在需要特定类型的操作符链中轻松组合和包含。

------

