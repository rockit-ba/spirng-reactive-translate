# 7 Spring WebFlux

Spring框架中包含的原始web框架，Spring web MVC，是专门为Servlet API和Servlet容器而构建的。响应式堆栈web框架Spring WebFlux是在5.0版本中添加的。它是完全无阻塞的，支持响应流回压，并运行在Netty、Undertow和Servlet 3.1+容器等服务器上。

这两个web框架都反映了它们的源模块的名称(Spring -webmvc和Spring -webflux)，并在Spring框架中共存。每个模块都是可选的。应用程序可以使用一个或另一个模块，或者在某些情况下同时使用两个模块——例如，带有响应性WebClient的Spring MVC控制器。

## 1 概览

为什么要创建Spring WebFlux ?

部分原因是需要一个非阻塞的web堆栈来处理少量线程的并发性，并使用更少的硬件资源进行扩展。Servlet 3.1确实为非阻塞I/O提供了一个API。然而，使用它会远离Servlet API的其他部分，其中契约是同步的(Filter, Servlet)或阻塞的(getParameter, getPart)。这是一个新的通用API作为任何非阻塞运行时的基础的动机。这很重要，因为服务器(如Netty)是在异步、非阻塞空间中建立的。

答案的另一部分是函数式编程。就像Java 5中添加注释创造了机会(比如带注释的REST控制器或单元测试)一样，Java 8中添加lambda表达式也为Java中的功能性api创造了机会。这对于允许声明式组合异步逻辑的非阻塞应用程序和延续风格的api(由CompletableFuture和ReactiveX普及)来说是一个福音。在编程模型级别，Java 8使Spring WebFlux能够提供功能性的web端点和带注释的控制器。

### 定义“Reactive”

我们谈到了“非阻塞”和“功能性”（“non-blocking” and “functional” ），但是反应性是什么意思呢?

术语“反应性”指的是围绕对变化作出反应而构建的编程模型——网络组件对I/O事件作出反应，UI控制器对鼠标事件作出反应，等等。从这个意义上说，非阻塞是反应性的，因为我们现在处于操作完成或数据可用时响应通知的模式，而不是被阻塞。

还有另一个重要的机制，我们在Spring团队中与“反应性”联系在一起，那就是无阻塞的背压。在同步的命令式代码中，阻塞调用是迫使调用者等待的一种自然形式的背压。在非阻塞代码中，控制事件的速率使快速的生成器不会淹没其目标变得很重要。

响应流（Reactive Streams）是一个小规范(也在Java 9中采用)，它定义了带有背压的异步组件之间的交互。例如，数据存储库(充当发布服务器)可以生成HTTP服务器(充当订阅服务器)随后可以写入响应的数据。响应流的主要目的是让订阅者控制发布者产生数据的速度。

> 常见问题:如果publisher不能放慢速度怎么办?
>
> 响应式流的目的只是建立机制和边界。如果publisher不能放慢速度，它就必须决定是缓冲、删除还是失败。

### Reactive API

> 响应流是webflux的基础：reactor实现了reactive stream规范，然后webflux基于reactor实现。

响应式流在互操作性中扮演着重要的角色。它对库和基础设施组件很感兴趣，但作为应用程序API用处不大，因为它太低级了。应用程序需要一个更高级、更丰富的功能性API来组成异步逻辑——类似于Java 8 Stream API，但不只是用于集合。这就是反应性库所扮演的角色。

Reactor是Spring WebFlux的反应性库的选择。它提供Mono和Flux API类型来处理0..1的数据序列(Mono)和0 . .N (Flux)到一组与操作符的ReactiveX词汇表对齐的丰富操作符。*Reactor是一个Reactive Streams库*，因此，它的所有操作人员都支持无阻塞的背压。Reactor非常关注服务器端Java。它是与Spring紧密协作开发的。

WebFlux需要Reactor作为一个核心依赖，但是它可以通过reactive Streams与其他的reactive库互操作。作为一个通用规则，WebFlux API接受一个普通的Publisher作为输入，在内部将其调整为一个Reactor类型，使用它，并返回一个Flux或Mono作为输出。因此，您可以传递任何Publisher作为输入，并可以对输出应用操作，但您需要调整输出以便与另一个响应式库一起使用。只要可行(例如，带注释的控制器)，WebFlux就会透明地适应RxJava或其他响应性库的使用。

> 除了响应式api之外，WebFlux还可以与Kotlin中的协程api一起使用，后者提供了一种更命定的编程风格。

### Programming Models（编程模型）

Spring -web模块包含了Spring WebFlux的响应式基础，包括HTTP抽象、响应式流适配器，支持的服务器、编解码器和一个核心的WebHandler API，类似于Servlet API，但没有阻塞协议。

在此基础上，Spring WebFlux提供了两种编程模型的选择:

[Annotated Controllers](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-controller):与Spring MVC一致，并且基于Spring -web模块的相同注解。Spring MVC和WebFlux控制器都支持响应式(Reactor和RxJava)返回类型，因此，很难将它们区分开来。一个显著的区别是，WebFlux也支持响应式@RequestBody参数。

[Functional Endpoints](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-fn): 基于lambda的轻量级函数式编程模型。您可以将其视为应用程序可以用来路由和处理请求的一个小库或一组实用程序。带注释的控制器的最大区别在于，应用程序从头到尾负责请求处理，而不是通过注释声明意图并被回调。

### Applicability（适用性）

Spring MVC还是WebFlux?

这是一个很自然的问题，但却建立了一个不合理的二分法。实际上，两者共同努力扩大了可用选择的范围。这两种设计都是为了彼此的连续性和一致性，它们可以并排使用，并且来自每一方的反馈对双方都有利。下图显示了两者之间的关系，它们有什么共同之处，以及它们各自支持的独特之处:

![image-20210628090250969](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210628090250969.png)

------

我们建议您考虑以下几点:

- 如果您有一个运行良好的Spring MVC应用程序，则不需要进行更改。命令式编程是编写、理解和调试代码的最简单方法。您可以选择最多的库，因为从历史上看，大多数库都是阻塞的。
- 如果你已经在购买一个非阻塞的web堆栈，Spring WebFlux提供了与其他网站相同的执行模型优势，还提供了服务器(Netty, Tomcat, Jetty, Undertow和Servlet 3.1+容器)，编程模型(带注释的控制器和功能web端点)，并选择响应式库(Reactor、RxJava或其他)。
- 如果你对使用Java 8 lambdas或Kotlin的轻量级功能web框架感兴趣，你可以使用Spring WebFlux功能web端点。对于需求不那么复杂的小型应用程序或微服务来说，这也是一个很好的选择，这些应用程序或微服务可以受益于更大的透明度和控制。
- 在微服务体系结构中，你可以混合使用Spring MVC或Spring WebFlux控制器或Spring WebFlux功能端点的应用。在两个框架中支持相同的基于注释的编程模型，可以更容易地重用知识，同时为正确的工作选择正确的工具。
- 评估应用程序的一个简单方法是检查它的依赖关系。如果您需要使用阻塞持久性api (JPA、JDBC)或网络api，那么Spring MVC至少是通用架构的最佳选择。在技术上，用Reactor和RxJava在单独的线程上执行阻塞调用是可行的，但你不会充分利用非阻塞的web堆栈。
- 如果你有一个Spring MVC应用程序调用远程服务，试试响应式WebClient。您可以直接从Spring MVC控制器方法返回响应类型(Reactor、RxJava或其他)。每个调用的延迟时间或调用之间的相互依赖性越大，好处就越大。Spring MVC控制器也可以调用其他响应性组件。
- 如果您有一个大型的团队，请记住，在向非阻塞、函数式和声明式编程的转变过程中，需要经历陡峭的学习曲线。一个不需要完全切换就启动的实用方法是使用响应式WebClient。除此之外，从小事做起，衡量好处。我们预计，对于广泛的应用来说，这种转变是不必要的。如果您不确定要寻找什么好处，可以从学习非阻塞I/O如何工作(例如，单线程Node.js上的并发性)及其影响开始。

### Servers

Spring WebFlux支持Tomcat, Jetty, Servlet 3.1+容器，以及Netty和Undertow等非Servlet运行时。所有服务器都适应于低级的公共API，这样就可以跨服务器支持高级编程模型。

Spring WebFlux没有启动或停止服务器的内置支持。然而，很容易从Spring配置和WebFlux基础设施组装一个应用程序，并使用几行代码运行它。

Spring Boot有一个WebFlux启动器，可以自动执行这些步骤。默认情况下，初学者使用Netty，但是通过改变Maven或Gradle的依赖关系，很容易切换到Tomcat、Jetty或Undertow。Spring Boot默认为Netty，因为它更广泛地用于异步、非阻塞空间，并允许客户端和服务器共享资源。

Tomcat和Jetty可以与Spring MVC和WebFlux一起使用。但是请记住，它们的使用方式是非常不同的。Spring MVC依赖于Servlet阻塞I/O，并允许应用程序在需要时直接使用Servlet API。Spring WebFlux依赖于Servlet 3.1非阻塞I/O，并使用底层适配器背后的Servlet API。不能直接使用。

对于Undertow, Spring WebFlux直接使用Undertow API，而不使用Servlet API。

### 性能

性能具有许多特征和意义。反应性和非阻塞通常不会使应用程序运行得更快。在某些情况下，它们可以(例如，如果使用WebClient并行运行远程调用)。总的来说，非阻塞方式需要更多的工作，这可能会略微增加所需的处理时间。

反应性和非阻塞的主要预期好处是能够使用少量固定数量的线程和更少的内存进行扩展。这使得应用程序在负载下更有弹性，因为它们可以以更可预测的方式伸缩。然而，为了观察这些好处，您需要有一些延迟(包括缓慢和不可预测的网络I/O)。这就是反应性堆栈开始显示其优势的地方，差异可能是戏剧性的。

### 并发模型

Spring MVC和Spring WebFlux都支持带注释的控制器，但是在并发模型和阻塞和线程的默认假设上有一个关键的区别。

在Spring MVC(以及一般的servlet应用程序)中，假定应用程序可以阻塞当前线程(例如，对于远程调用)。因此，servlet容器使用大型线程池来吸收请求处理期间可能出现的阻塞。

在Spring WebFlux(以及一般的非阻塞服务器)中，假定应用程序不会阻塞。因此，非阻塞服务器使用一个小的、固定大小的线程池(事件循环工作者)来处理请求。

> “扩展”和“少量线程”听起来可能矛盾，但永远不阻塞当前线程(而依赖回调)意味着你不需要额外的线程，因为没有阻塞调用需要吸收。

**调用阻塞API**

如果您确实需要使用一个阻塞库怎么办?Reactor和RxJava都提供了publishOn操作符，以在不同的线程上继续处理。这意味着有个容易的逃生口。但是，请记住，阻塞api并不适合这种并发模型。

**可变状态**

在Reactor和RxJava中，通过操作符声明逻辑。在运行时，会形成一个响应式管道，其中数据会在不同的阶段顺序处理。这样做的一个关键好处是，它使应用程序不必保护可变状态，因为该管道中的应用程序代码永远不会并发调用。

**线程模型**

您希望在使用Spring WebFlux运行的服务器上看到哪些线程?

- 在一个“普通的”Spring WebFlux服务器上(例如，没有数据访问或其他可选依赖项)，您可以期望一个线程用于服务器，其他几个线程用于请求处理(通常和CPU内核的数量一样多)。然而，Servlet容器可能以更多的线程(例如，Tomcat上的10个线程)启动，以支持Servlet(阻塞)I/O和Servlet 3.1(非阻塞)I/O的使用。
- 响应式WebClient以事件循环方式操作。因此，您可以看到与此相关的少量、固定数量的处理线程(例如，Reactor -http-nio-带有Reactor Netty连接器)。但是，如果反应器Netty同时用于客户端和服务器，这两个共享事件循环资源在默认情况下。
- Reactor和RxJava提供了线程池抽象，称为调度程序，用于publishOn操作符，该操作符用于将处理切换到不同的线程池。调度器有建议特定并发策略的名称——例如，“并行”(用于线程数量有限的cpu绑定工作)或“弹性”(用于I/ o绑定工作，用于线程数量很大)。如果您看到这样的线程，这意味着某些代码正在使用特定的线程池调度器策略。
- 数据访问库和其他第三方依赖项也可以创建和使用它们自己的线程。

**配置**

Spring框架不支持启动和停止服务器。要为服务器配置线程模型，您需要使用特定于服务器的配置api，或者，如果您使用Spring Boot，请检查每个服务器的Spring Boot配置选项。您可以直接配置WebClient。对于所有其他库，请参阅它们各自的文档。

## 2 Reactive Core

spring-web模块包含了以下对响应式web应用程序的基本支持:

- 对于服务器请求处理，有两个级别的支持。

  HttpHandler: HTTP请求处理的基本协议，使用无阻塞I/O和响应流返回压力，以及用于反应器Netty、Undertow、Tomcat、Jetty和任何Servlet 3.1+容器的适配器。

  WebHandler API:稍高级的、用于请求处理的通用web API，在其之上构建具体的编程模型，如带注释的控制器和功能端点。

- 对于客户端，有一个基本的ClientHttpConnector契约来执行带有非阻塞I/O和响应流回压的HTTP请求，以及用于反应器Netty、响应Jetty HttpClient和Apache HttpComponents的适配器。应用程序中使用的高级WebClient建立在这个基本契约之上。

- 对于客户机和服务器，用于序列化和反序列化HTTP请求和响应内容的编解码器。

### `HttpHandler`

HttpHandler是一个简单的契约，只有一个方法来处理请求和响应。它的主要和唯一目的是对不同的HTTP服务器api进行最小的抽象。

支持的服务器接口如下表所示:

| Server name           | Server API used                                              | Reactive Streams support                                     |
| :-------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Netty                 | Netty API                                                    | [Reactor Netty](https://github.com/reactor/reactor-netty)    |
| Undertow              | Undertow API                                                 | spring-web: Undertow to Reactive Streams bridge              |
| Tomcat                | Servlet 3.1 non-blocking I/O; Tomcat API to read and write ByteBuffers vs byte[] | spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge |
| Jetty                 | Servlet 3.1 non-blocking I/O; Jetty API to write ByteBuffers vs byte[] | spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge |
| Servlet 3.1 container | Servlet 3.1 non-blocking I/O                                 | spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge |

下表描述了服务器依赖关系

| Server name   | Group id                | Artifact name               |
| :------------ | :---------------------- | :-------------------------- |
| Reactor Netty | io.projectreactor.netty | reactor-netty               |
| Undertow      | io.undertow             | undertow-core               |
| Tomcat        | org.apache.tomcat.embed | tomcat-embed-core           |
| Jetty         | org.eclipse.jetty       | jetty-server, jetty-servlet |

下面的代码片段显示了如何使用HttpHandler适配器和每个服务器API:

**reactor-netty**

```java
HttpHandler handler = ...
ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);
HttpServer.create().host(host).port(port).handle(adapter).bind().block();
```

**Undertow**

```java
HttpHandler handler = ...
UndertowHttpHandlerAdapter adapter = new UndertowHttpHandlerAdapter(handler);
Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();
server.start();
```

**Tomcat**

```java
HttpHandler handler = ...
Servlet servlet = new TomcatHttpHandlerAdapter(handler);

Tomcat server = new Tomcat();
File base = new File(System.getProperty("java.io.tmpdir"));
Context rootContext = server.addContext("", base.getAbsolutePath());
Tomcat.addServlet(rootContext, "main", servlet);
rootContext.addServletMappingDecoded("/", "main");
server.setHost(host);
server.setPort(port);
server.start();
```

**Jetty**

```java
HttpHandler handler = ...
Servlet servlet = new JettyHttpHandlerAdapter(handler);

Server server = new Server();
ServletContextHandler contextHandler = new ServletContextHandler(server, "");
contextHandler.addServlet(new ServletHolder(servlet), "/");
contextHandler.start();

ServerConnector connector = new ServerConnector(server);
connector.setHost(host);
connector.setPort(port);
server.addConnector(connector);
server.start();
```

**Servlet 3.1+ Container**

要将WAR部署到任何Servlet 3.1+容器，您可以在WAR中扩展并包含AbstractReactiveWebInitializer。该类用ServletHttpHandlerAdapter包装一个HttpHandler，并将其注册为Servlet。

### `WebHandler` API

org.springframework.web.server包构建在HttpHandler合约之上，提供了一个通用的web API，用于通过一个由多个webxceptionhandler、多个WebFilter和单个WebHandler组件组成的链来处理请求。这个链可以通过简单地指向一个自动检测组件的Spring ApplicationContext来与WebHttpHandlerBuilder组合在一起，或者通过向构建器注册组件来实现。

HttpHandler的目标是抽象不同HTTP服务器的使用，而WebHandler API的目标是提供更广泛的web应用中常用的特性，例如:

- 带有属性的user session。
- Request attributes.
- 解析 `Locale` or `Principal` for the request.
- Access to parsed and cached form data.

#### 特殊的bean类型

下表列出了WebHttpHandlerBuilder可以在Spring ApplicationContext中自动检测到的组件，或者可以直接注册到Spring ApplicationContext中:

| <any>                        | `WebExceptionHandler`        | 0..N | 为来自WebFilter实例链和目标WebHandler的异常提供处理。        |
| ---------------------------- | ---------------------------- | ---- | ------------------------------------------------------------ |
| <any>                        | `WebFilter`                  | 0..N | 将拦截样式逻辑应用于过滤器链的其余部分和目标WebHandler的前后。 |
| `webHandler`                 | `WebHandler`                 | 1    | The handler for the request.                                 |
| `webSessionManager`          | `WebSessionManager`          | 0..1 | 通过serverwebeexchange上的方法公开的WebSession实例的管理器。默认DefaultWebSessionManager。 |
| `serverCodecConfigurer`      | `ServerCodecConfigurer`      | 0..1 | 访问HttpMessageReader实例，用于解析表单数据和多部分数据，这些数据随后通过ServerWebExchange上的方法公开。默认ServerCodecConfigurer.create()。 |
| `localeContextResolver`      | `LocaleContextResolver`      | 0..1 | 通过serverwebeexchange上的方法公开的LocaleContext解析器。默认AcceptHeaderLocaleContextResolver。 |
| `forwardedHeaderTransformer` | `ForwardedHeaderTransformer` | 0..1 | 用于处理转发的类型头，可以提取和删除它们，也可以只删除它们。默认情况下不使用。 |

#### Form Data

ServerWebExchange公开了以下访问表单数据的方法:

```java
Mono<MultiValueMap<String, String>> getFormData();
```

DefaultServerWebExchange使用配置好的HttpMessageReader来解析表单数据(application/x-www-form-urlencoded)到一个MultiValueMap。默认情况下，FormHttpMessageReader被配置为由ServerCodecConfigurer bean使用

#### Multipart Data

ServerWebExchange公开了以下访问多部分数据的方法:

```java
Mono<MultiValueMap<String, Part>> getMultipartData();
```

DefaultServerWebExchange使用配置好的HttpMessageReader<MultiValueMap<String, Part>>来将多部分/form-data内容解析为MultiValueMap。默认情况下，这是DefaultPartHttpMessageReader，它没有任何第三方依赖项。或者，可以使用SynchronossPartHttpMessageReader，它是基于synchronosnio Multipart库的。两者都是通过ServerCodecConfigurer bean配置的。

要以流方式解析多部分数据，可以使用从HttpMessageReader<Part>返回的Flux<Part>。例如，在带注释的控制器中，使用@RequestPart意味着按名称对各个部分进行类似map的访问，因此需要完整地解析多部分数据。相反，你可以使用@RequestBody将内容解码到Flux<Part>，而不用收集到MultiValueMap。

####  Forwarded Headers

当请求通过代理(如负载均衡器)时，主机、端口和方案可能会发生变化。因此，从客户机的角度来看，创建指向正确的主机、端口和方案的链接很困难。

RFC 7239定义了转发HTTP报头，代理可以使用它来提供关于原始请求的信息。还有其他非标准头文件，包括x - forward - host, x - forward - port, x - forward - proto, x - forward - ssl和x - forward - prefix。

ForwardedHeaderTransformer是一个组件，它根据转发的头修改请求的主机、端口和方案，然后删除这些头。如果您将它声明为一个名为forwardedHeaderTransformer的bean，那么它将被检测和使用。

对于转发的头有安全考虑，因为应用程序不能知道头是按预期由代理添加的，还是由恶意客户端添加的。这就是为什么应该配置位于信任边界的代理来删除来自外部的不受信任的转发流量的原因。你也可以用removeOnly=true来配置ForwardedHeaderTransformer，在这种情况下，它会删除但不使用头文件。

> 在5.1中，ForwardedHeaderFilter被ForwardedHeaderTransformer所取代，所以转发的头信息可以在交换创建之前被更早地处理。如果以任何方式配置了过滤器，它将从过滤器列表中取出，并使用ForwardedHeaderTransformer。

###  Filters

在WebHandler API中，您可以使用WebFilter在过滤器处理链的其余部分和目标WebHandler之后应用拦截风格的逻辑。当使用WebFlux Config时，注册一个WebFilter就像将它声明为一个Spring bean一样简单，并(可选地)通过在bean声明上使用@Order或实现order来表示优先级。

#### CORS

Spring WebFlux通过控制器上的注解为CORS配置提供了细粒度的支持。然而，当你与Spring Security一起使用它时，我们建议依赖于内置的CorsFilter，它必须在Spring Security的过滤器链之前排序。

### Exceptions

在WebHandler API中，你可以使用WebExceptionHandler来处理来自WebFilter实例链和目标WebHandler的异常。当使用WebFlux Config时，注册一个webxceptionhandler就像将它声明为一个Spring bean一样简单，并(可选地)通过在bean声明上使用@Order或实现order来表示优先级。

下表描述了可用的WebExceptionHandler实现:

| Exception Handler                       | Description                                                  |
| :-------------------------------------- | :----------------------------------------------------------- |
| `ResponseStatusExceptionHandler`        | Provides handling for exceptions of type [`ResponseStatusException`](https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/web/server/ResponseStatusException.html) by setting the response to the HTTP status code of the exception. |
| `WebFluxResponseStatusExceptionHandler` | Extension of `ResponseStatusExceptionHandler` that can also determine the HTTP status code of a `@ResponseStatus` annotation on any exception.This handler is declared in the [WebFlux Config](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config). |

### 编解码器

spring-web和spring-core模块通过无阻塞I/O和Reactive Streams压力提供了对字节内容的序列化和反序列化的支持。以下描述了这种支持:

`Encoder` 和 `Decoder`是独立于HTTP对内容进行编码和解码的低级契约。

`HttpMessageReader`和`HttpMessageWriter`是用于编码和解码HTTP消息内容的契约。

`Encoder`可以用`EncoderHttpMessageWriter`封装，以适应在web应用程序中使用，而Decoder可以用DecoderHttpMessageReader封装。

`DataBuffer`抽象了不同的字节缓冲区表示(例如Netty ByteBuf, java.nio。ByteBuffer等)，是所有编解码器的工作。关于这个主题的更多信息，请参阅“Spring Core”部分中的数据缓冲区和编解码器。

spring-core模块提供了byte[]、ByteBuffer、DataBuffer、Resource和String编码器和解码器实现。spring-web模块提供Jackson JSON、Jackson Smile、JAXB2、Protocol Buffers和其他编码器和解码器，以及用于表单数据、多部分内容、服务器发送事件等的仅web的HTTP消息读取器和写入器实现。

ClientCodecConfigurer和ServerCodecConfigurer通常用于配置和定制在应用程序中使用的编解码器。

详情：[Web on Reactive Stack (spring.io)](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-codecs)

### Logging

在Spring WebFlux中，DEBUG级别的日志被设计成紧凑、最小和人性化的。它关注的是反复有用的高价值信息位，而不是只在调试特定问题时有用的信息位。

TRACE级别的日志记录通常遵循与DEBUG相同的原则(例如，也不应该是一个消防软管)，但可以用于调试任何问题。此外，一些日志消息可能在TRACE和DEBUG中显示不同级别的详细信息。

好的日志记录来自于使用日志的经验。

#### Log Id

在WebFlux中，单个请求可以在多个线程上运行，线程ID 对于关联属于特定请求的日志消息没有用处。这就是为什么WebFlux日志消息在默认情况下使用一个特定于请求的ID作为前缀的原因。

在服务器端，日志ID存储在ServerWebExchange属性(LOG_ID_ATTRIBUTE)中，而基于该ID的完整格式化前缀可以从`ServerWebExchange#getLogPrefix()`中获得。在WebClient端，日志ID存储在ClientRequest属性(LOG_ID_ATTRIBUTE)中，而完全格式化的前缀可以从ClientRequest#logPrefix()中获得。

#### 敏感数据

DEBUG和TRACE日志可以记录敏感信息。这就是为什么表单参数和头在默认情况下被屏蔽，而您必须显式地完全启用它们的日志记录。

下面的例子展示了如何为服务器端请求这样做:

```java
@Configuration
@EnableWebFlux
class MyConfig implements WebFluxConfigurer {

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        configurer.defaultCodecs().enableLoggingRequestDetails(true);
    }
}
```

下面的例子展示了如何处理客户端请求:

```java
Consumer<ClientCodecConfigurer> consumer = configurer ->
        configurer.defaultCodecs().enableLoggingRequestDetails(true);

WebClient webClient = WebClient.builder()
        .exchangeStrategies(strategies -> strategies.codecs(consumer))
        .build();
```

#### Appenders

日志库(如SLF4J和Log4J 2)提供了避免阻塞的异步日志记录器。虽然这些方法有其自身的缺点，比如可能会删除不能排队进行日志记录的消息，但它们是当前在响应性、非阻塞应用程序中使用的最佳可用选项。

#### Custom codecs

应用程序可以注册自定义编解码器以支持其他媒体类型，或默认编解码器不支持的特定行为。

开发人员表示的一些配置选项在默认编解码器上强制执行。自定义编解码器可能希望有机会与这些首选项对齐，比如强制缓冲限制或记录敏感数据。

下面的例子展示了如何处理客户端请求:

```java
WebClient webClient = WebClient.builder()
        .codecs(configurer -> {
                CustomDecoder decoder = new CustomDecoder();
                configurer.customCodecs().registerWithDefaultConfig(decoder);
        })
        .build();
```

## 3 `DispatcherHandler`

与Spring MVC类似，Spring WebFlux是围绕前端控制器模式设计的，其中一个中央WebHandler (DispatcherHandler)为请求处理提供了共享算法，而实际工作是由可配置的委托组件执行的。该模型灵活，支持多种工作流。

DispatcherHandler从Spring配置中发现它需要的委托组件。它本身也是一个Spring bean，并实现了ApplicationContextAware来访问它运行的上下文。如果DispatcherHandler用webHandler的bean名来声明，那么它会被WebHttpHandlerBuilder发现，它会像webHandler API中描述的那样将请求处理链放在一起。

WebFlux应用中的Spring配置通常包含:

- bean名为webHandler的DispatcherHandler
- WebFilter和webxceptionhandler bean
- DispatcherHandler特殊bean
- other

这个配置是给WebHttpHandlerBuilder来构建处理链的，如下面的例子所示:

```java
ApplicationContext context = ...
HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context).build();
```

生成的HttpHandler可以与服务器适配器一起使用了。

### 特殊的Bean类型

DispatcherHandler委托给特殊的bean来处理请求并呈现适当的响应。我们所说的“特殊bean”是指实现WebFlux框架契约的spring管理对象实例。它们通常带有内置的契约，但是您可以自定义它们的属性、扩展它们或替换它们。

下表列出了DispatcherHandler检测到的特殊bean。注意，还有一些其他的bean在较低的级别被检测到(请参阅Web处理程序API中的特殊bean类型)。

| Bean type              | Explanation                                                  |
| :--------------------- | :----------------------------------------------------------- |
| `HandlerMapping`       | 将请求映射到处理程序。映射基于一些标准，其细节因HandlerMapping实现而不同——带注释的控制器、简单URL模式映射等。HandlerMapping的主要实现包括RequestMappingHandlerMapping用于@RequestMapping带注释的方法，RouterFunctionMapping用于功能性端点路由，SimpleUrlHandlerMapping用于URI路径模式和WebHandler实例的显式注册。 |
| `HandlerAdapter`       | 帮助DispatcherHandler调用映射到请求的处理程序，而不管该处理程序实际上是如何调用的。例如，调用带注释的控制器需要解析注释。HandlerAdapter的主要目的是对DispatcherHandler屏蔽这些细节。 |
| `HandlerResultHandler` | 处理处理程序调用的结果并最后确定响应。看到结果处理。         |

### WebFlux Config

应用程序可以声明处理请求所需的基础设施bean(在Web处理程序API和DispatcherHandler下列出)。然而，在大多数情况下，WebFlux配置是最好的起点。它声明所需的bean，并提供更高级的配置回调API来对其进行定制。

Spring Boot依赖于WebFlux配置来配置Spring WebFlux，还提供了许多额外的方便选项。

### Processing

DispatcherHandler处理请求如下:

- 每个HandlerMapping都被要求找到一个匹配的处理程序，并且使用第一个匹配。
- 如果找到处理程序，则通过适当的HandlerAdapter运行它，该HandlerAdapter将执行的返回值公开为HandlerResult。
- HandlerResult被赋给适当的HandlerResultHandler，通过直接写入响应或使用视图呈现来完成处理。

### Result Handling

通过HandlerAdapter调用处理程序的返回值被包装为HandlerResult以及一些额外的上下文，并传递给第一个声明支持它的HandlerResultHandler。下表显示了可用的HandlerResultHandler实现，所有这些都在WebFlux配置中声明:

| Result Handler Type           | Return Values                                                | Default Order       |
| :---------------------------- | :----------------------------------------------------------- | :------------------ |
| `ResponseEntityResultHandler` | `ResponseEntity`, typically from `@Controller` instances.    | 0                   |
| `ServerResponseResultHandler` | `ServerResponse`, typically from functional endpoints.       | 0                   |
| `ResponseBodyResultHandler`   | Handle return values from `@ResponseBody` methods or `@RestController` classes. | 100                 |
| `ViewResolutionResultHandler` | `CharSequence`, [`View`](https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/web/reactive/result/view/View.html), [Model](https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/ui/Model.html), `Map`, [Rendering](https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html), or any other `Object` is treated as a model attribute.See also [View Resolution](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-viewresolution). | `Integer.MAX_VALUE` |

### Exceptions

从HandlerAdapter返回的HandlerResult可以根据某些特定于处理程序的机制公开用于错误处理的函数。这个错误函数在以下情况下被调用:

- 处理程序(例如，@Controller)调用失败。
- 通过HandlerResultHandler处理处理程序返回值失败。

错误函数可以更改响应(例如，更改为错误状态)，只要在从处理程序返回的响应类型产生任何数据项之前出现错误信号。

这就是支持@Controller类中的@ExceptionHandler方法的方式。相比之下，Spring MVC中对相同的支持是建立在HandlerExceptionResolver上的。这通常不重要。***但是，请记住，在WebFlux中，你不能使用@ControllerAdvice来处理在处理程序被选择之前发生的异常。***

### View Resolution

视图解析允许使用HTML模板和模型向浏览器呈现，而无需将您绑定到特定的视图技术。在Spring WebFlux中，视图解析通过专门的HandlerResultHandler得到支持，该HandlerResultHandler使用ViewResolver实例将一个String(代表一个逻辑视图名)映射到一个view实例。然后使用视图来呈现响应。

(基于目前前后端分离的趋势，跳过此段内容，详细查看官网)

## 4 Annotated Controllers

Spring WebFlux提供了一个基于注释的编程模型，其中@Controller和@RestController组件使用注释来表示请求映射、请求输入、处理异常等。带注释的控制器具有灵活的方法签名，并且不必扩展基类或实现特定的接口。

下面的清单显示了一个基本的示例:

```java
@RestController
public class HelloController {

    @GetMapping("/hello")
    public String handle() {
        return "Hello WebFlux";
    }
}
```

在前面的示例中，该方法返回一个要写入响应体的String。

### `@Controller`

您可以使用标准的Spring bean定义来定义控制器bean。@Controller原型允许自动检测，并与Spring对检测类路径中的@Component类和为它们自动注册bean定义的通用支持保持一致。它还充当注释类的原型，指示其作为web组件的角色。

要启用这种@Controller bean的自动检测，您可以在Java配置中添加组件扫描，如下面的示例所示:

```java
@Configuration
// 	Scan the org.example.web package.
@ComponentScan("org.example.web") 
public class WebConfig {

    // ...
}
```

@RestController是一个组合注释，它本身是用@Controller和@ResponseBody元注释的，表示该控制器的每个方法都继承了类型级的@ResponseBody注释，因此，它直接写入响应体，而不是用HTML模板解析和呈现视图。

### Request Mapping

@RequestMapping注释用于将请求映射到控制器方法。它有各种属性，可以根据URL、HTTP方法、请求参数、标头和媒体类型进行匹配。您可以在类级别使用它来表示共享映射，或者在方法级别使用它来缩小到特定端点映射。

- `@GetMapping`
- `@PostMapping`
- `@PutMapping`
- `@DeleteMapping`
- `@PatchMapping`

前面提供的注解是自定义注释，因为可以证明，大多数控制器方法应该映射到特定的HTTP方法，而不是使用@RequestMapping，后者默认情况下匹配所有HTTP方法。与此同时，***仍然需要在类级别上使用@RequestMapping来表示共享映射。***

下面的例子使用了类型和方法级别的映射:

```java
@RestController
@RequestMapping("/persons")
class PersonController {

    @GetMapping("/{id}")
    public Person getPerson(@PathVariable Long id) {
        // ...
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public void add(@RequestBody Person person) {
        // ...
    }
}
```

#### URI Patterns

| Pattern         | Description                                                  | Example                                                      |
| :-------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `?`             | Matches one character                                        | `"/pages/t?st.html"` matches `"/pages/test.html"` and `"/pages/t3st.html"` |
| `*`             | Matches zero or more characters within a path segment        | `"/resources/*.png"` matches `"/resources/file.png"``"/projects/*/versions"` matches `"/projects/spring/versions"` but does not match `"/projects/spring/boot/versions"` |
| `**`            | Matches zero or more path segments until the end of the path | `"/resources/**"` matches `"/resources/file.png"` and `"/resources/images/file.png"``"/resources/**/file.png"` is invalid as `**` is only allowed at the end of the path. |
| `{name}`        | Matches a path segment and captures it as a variable named "name" | `"/projects/{project}/versions"` matches `"/projects/spring/versions"` and captures `project=spring` |
| `{name:[a-z]+}` | Matches the regexp `"[a-z]+"` as a path variable named "name" | `"/projects/{project:[a-z]+}/versions"` matches `"/projects/spring/versions"` but not `"/projects/spring1/versions"` |
| `{*path}`       | Matches zero or more path segments until the end of the path and captures it as a variable named "path" | `"/resources/{*file}"` matches `"/resources/images/file.png"` and captures `file=images/file.png` |

捕获的URI变量可以通过@PathVariable访问，如下所示:

```java
@GetMapping("/owners/{ownerId}/pets/{petId}")
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
    // ...
}
```

你可以在类和方法级别声明URI变量，如下面的例子所示:

```java
@Controller
@RequestMapping("/owners/{ownerId}") 
public class OwnerController {

    @GetMapping("/pets/{petId}") 
    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
        // ...
    }
}
```

#### Consumable Media Types

```java
@PostMapping(path = "/pets", consumes = "application/json")
public void addPet(@RequestBody Pet pet) {
    // ...
}
```

> MediaType为常用的媒体类型提供常量——例如，APPLICATION_JSON_VALUE和APPLICATION_XML_VALUE。

#### Producible Media Types

您可以根据Accept请求头和控制器方法生成的内容类型列表缩小请求映射，如下面的示例所示:

```java
@GetMapping(path = "/pets/{petId}", produces = "application/json")
@ResponseBody
public Pet getPet(@PathVariable String petId) {
    // ...
}
```

#### Parameters and Headers

您可以根据查询参数条件缩小请求映射。您可以测试是否存在查询参数(myParam)，是否存在查询参数(!myParam)，或者是否存在特定的值(myParam=myValue)。以下示例测试具有值的参数:

```java
// 	Check that myParam equals myValue.
@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") 
public void findPet(@PathVariable String petId) {
    // ...
}
```

你也可以使用相同的请求头条件，如下面的例子所示:

```java
@GetMapping(path = "/pets", headers = "myHeader=myValue") 
public void findPet(@PathVariable String petId) {
    // ...
}
```

### Handler Methods

@RequestMapping处理程序方法有一个灵活的签名，可以从一系列支持的控制器方法参数和返回值中进行选择。

#### Method Arguments

| Controller method argument                                   | Description                                                  |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| `ServerWebExchange`                                          | 访问完整的serverwebeexchange容器，用于HTTP请求和响应、请求和会话属性、checkNotModified方法等。 |
| `ServerHttpRequest`, `ServerHttpResponse`                    | 访问HTTP请求或响应。                                         |
| `WebSession`                                                 | 访问会话。除非添加了属性，否则不会强制启动新会话。支持反应类型。 |
| `java.security.Principal`                                    | 当前已验证的用户——如果已知，可能是特定的Principal实现类。支持反应类型。 |
| `org.springframework.http.HttpMethod`                        | The HTTP method of the request.                              |
| `java.util.Locale`                                           | The current request locale, determined by the most specific `LocaleResolver` available — in effect, the configured `LocaleResolver`/`LocaleContextResolver`. |
| `java.util.TimeZone` + `java.time.ZoneId`                    | The time zone associated with the current request, as determined by a `LocaleContextResolver`. |
| `@PathVariable`                                              | For access to URI template variables. See [URI Patterns](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-requestmapping-uri-templates). |
| `@MatrixVariable`                                            | 用于访问URI路径段中的name-value。                            |
| `@RequestParam`                                              | For access to Servlet request parameters. Parameter values are converted to the declared method argument type. See [`@RequestParam`](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-requestparam).Note that use of `@RequestParam` is optional — for example, to set its attributes. See “Any other argument” later in this table. |
| `@RequestHeader`                                             | For access to request headers. Header values are converted to the declared method argument type. See [`@RequestHeader`](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-requestheader). |
| `@CookieValue`                                               | 访问cookie。Cookie值被转换为声明的方法参数类型。             |
| `@RequestBody`                                               | For access to the HTTP request body. Body content is converted to the declared method argument type by using `HttpMessageReader` instances. Supports reactive types. See [`@RequestBody`](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-requestbody). |
| `HttpEntity<B>`                                              | 用于访问请求头和正文。body被HttpMessageReader实例转换。      |
| `@RequestPart`                                               | 用于访问多部件/表单数据请求中的部件。支持反应类型。          |
| `java.util.Map`, `org.springframework.ui.Model`, and `org.springframework.ui.ModelMap`. | For access to the model that is used in HTML controllers and is exposed to templates as part of view rendering. |
| `@ModelAttribute`                                            | 用于访问模型中的现有属性(如果不存在则实例化)，并应用数据绑定和验证。 |
| `Errors`, `BindingResult`                                    | For access to errors from validation and data binding for a command object, i.e. a `@ModelAttribute` argument. An `Errors`, or `BindingResult` argument must be declared immediately after the validated method argument. |
| `SessionStatus` + class-level `@SessionAttributes`           | For marking form processing complete, which triggers cleanup of session attributes declared through a class-level `@SessionAttributes` annotation. See [`@SessionAttributes`](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-sessionattributes) for more details. |
| `UriComponentsBuilder`                                       | For preparing a URL relative to the current request’s host, port, scheme, and context path. See [URI Links](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-uri-building). |
| `@SessionAttribute`                                          | For access to any session attribute — in contrast to model attributes stored in the session as a result of a class-level `@SessionAttributes` declaration. See [`@SessionAttribute`](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-sessionattribute) for more details. |
| `@RequestAttribute`                                          | For access to request attributes. See [`@RequestAttribute`](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-requestattrib) for more details. |
| Any other argument                                           | If a method argument is not matched to any of the above, it is, by default, resolved as a `@RequestParam` if it is a simple type, as determined by [BeanUtils#isSimpleProperty](https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-), or as a `@ModelAttribute`, otherwise. |

###  ……

## 5 Functional Endpoints

Spring WebFlux包括WebFlux.Fn，是一种轻量级函数式编程模型，其中函数用于路由和处理请求，契约是为不可变性而设计的。它是基于注释的编程模型的替代方案，但是在相同的Reactive Core基础上运行。

### 概览

在WebFlux。fn, HTTP请求是通过HandlerFunction来处理的:这个函数接受ServerRequest并返回一个延迟的ServerResponse(即Mono<ServerResponse>)。请求和响应对象都有不可变的契约，提供了对HTTP请求和响应的JDK 8友好访问。HandlerFunction相当于基于注释的编程模型中的@RequestMapping方法的主体。

传入的请求被路由到一个带有RouterFunction的处理函数:这个函数接受ServerRequest并返回一个延迟的HandlerFunction(例如Mono<HandlerFunction>)。当路由器函数匹配时，返回一个handler函数;否则就是一个空的Mono。RouterFunction相当于@RequestMapping注释，但主要区别在于***路由器函数不仅提供数据，还提供行为***。

RouterFunctions.route()提供了一个路由器构建器，它有助于创建路由器，如下面的例子所示:

```java
import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.RequestPredicates.*;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction<ServerResponse> route = route()
    .GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson)
    .GET("/person", accept(APPLICATION_JSON), handler::listPeople)
    .POST("/person", handler::createPerson)
    .build();


public class PersonHandler {

    // ...

    public Mono<ServerResponse> listPeople(ServerRequest request) {
        // ...
    }

    public Mono<ServerResponse> createPerson(ServerRequest request) {
        // ...
    }

    public Mono<ServerResponse> getPerson(ServerRequest request) {
        // ...
    }
}
```

运行RouterFunction的一种方法是将它转换为HttpHandler，然后通过一个内置的服务器适配器安装它:

- `RouterFunctions.toHttpHandler(RouterFunction)`
- `RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)`

大多数应用程序可以通过WebFlux Java配置运行.

### HandlerFunction

ServerRequest和ServerResponse是不可变的接口，它们提供了对HTTP请求和响应的JDK 8友好访问。请求和响应都提供响应流对本体流的反压。请求体用 a Reactor `Flux` or `Mono`表示。响应体由任何响应流 `Publisher`表示，包括Flux和Mono.

**ServerRequest**

ServerRequest提供对HTTP方法、URI、头和查询参数的访问，而对主体的访问是通过主体方法提供的。

下面的例子将请求体提取为一个Mono<String>:

```java
Mono<String> string = request.bodyToMono(String.class);
```

下面的示例将主体提取为Flux<Person>(或Kotlin中的Flow<Person>)，其中Person对象从某些序列化形式(如JSON或XML)解码:

```java
Flux<Person> people = request.bodyToFlux(Person.class);
```

前面的例子是使用更通用的ServerRequest.body(BodyExtractor)的快捷方式，它接受BodyExtractor功能策略接口。实用程序类BodyExtractors提供了对许多实例的访问。例如，上面的例子也可以写成这样:

```java
Mono<String> string = request.body(BodyExtractors.toMono(String.class));
Flux<Person> people = request.body(BodyExtractors.toFlux(Person.class));
```

下面的例子展示了如何访问表单数据:

```java
Mono<MultiValueMap<String, String>> map = request.formData();
```

下面的例子展示了如何以映射的形式访问多部分数据:

```java
Flux<Part> parts = request.body(BodyExtractors.toParts());
```

**ServerResponse**

ServerResponse提供对HTTP响应的访问，由于它是不可变的，因此可以使用构建方法来创建它。您可以使用构建器来设置响应状态、添加响应头或提供响应体。下面的例子创建了一个包含JSON内容的200 (OK)响应:

```java
Mono<Person> person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person, Person.class);
```

下面的例子展示了如何构建一个带有Location标头而没有正文的201 (CREATED)响应:

```java
URI location = ...
ServerResponse.created(location).build();
```

根据所使用的编解码器，可以传递提示参数来定制体的序列化或反序列化方式。例如，要指定一个Jackson JSON视图:

```java
ServerResponse.ok().hint(Jackson2CodecSupport.JSON_VIEW_HINT, MyJacksonView.class).body(...);
```

**Handler Classes**

我们可以将处理函数写成lambda，如下面的例子所示:

```java
HandlerFunction<ServerResponse> helloWorld =
  request -> ServerResponse.ok().bodyValue("Hello World");
```

这很方便，但在应用程序中，我们需要多个函数，而多个内联lambda可能会很混乱。因此，将相关的处理程序函数分组到一个处理程序类中是很有用的，这个类在基于注释的应用程序中具有类似于@Controller的角色。例如，下面的类公开了一个响应式Person存储库:

```java
import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.ServerResponse.ok;

public class PersonHandler {

    private final PersonRepository repository;

    public PersonHandler(PersonRepository repository) {
        this.repository = repository;
    }
	
    // listPeople是一个处理函数，它将存储库中找到的所有Person对象返回为JSON。
    public Mono<ServerResponse> listPeople(ServerRequest request) { 
        Flux<Person> people = repository.allPeople();
        return ok().contentType(APPLICATION_JSON).body(people, Person.class);
    }

    public Mono<ServerResponse> createPerson(ServerRequest request) { 
        Mono<Person> person = request.bodyToMono(Person.class);
        return ok().build(repository.savePerson(person));
    }

    public Mono<ServerResponse> getPerson(ServerRequest request) { 
        int personId = Integer.valueOf(request.pathVariable("id"));
        return repository.getPerson(personId)
            .flatMap(person -> ok().contentType(APPLICATION_JSON).bodyValue(person))
            .switchIfEmpty(ServerResponse.notFound().build());
    }
}
```

**Validation**

功能端点可以使用Spring的验证工具对请求体应用验证。例如，给定一个Person的自定义Spring Validator实现:

```java
public class PersonHandler {
	// Create Validator instance.
    private final Validator validator = new PersonValidator(); 

    // ...

    public Mono<ServerResponse> createPerson(ServerRequest request) {
        // 使用验证。
        Mono<Person> person = request.bodyToMono(Person.class).doOnNext(this::validate); 
        return ok().build(repository.savePerson(person));
    }

    private void validate(Person person) {
        Errors errors = new BeanPropertyBindingResult(person, "person");
        validator.validate(person, errors);
        if (errors.hasErrors()) {
            // 对400响应引发异常。
            throw new ServerWebInputException(errors.toString()); 
        }
    }
}
```

处理程序还可以通过创建和注入一个基于LocalValidatorFactoryBean的全局Validator实例来使用标准bean验证API (JSR-303)。

### RouterFunction

路由器函数用于将请求路由到相应的HandlerFunction。通常情况下，你不用自己编写路由器函数，而是使用RouterFunctions实用程序类上的一个方法来创建一个。RouterFunctions.route()(没有参数)为你提供了一个流畅的构建器来创建一个路由器函数，而RouterFunctions.route(RequestPredicate, HandlerFunction)提供了一种直接创建路由器的方法。

通常，建议使用route() builder，因为它为典型的映射场景提供了方便的快捷方式，而不需要很难发现的静态导入。例如，路由器函数生成器提供了GET(String, HandlerFunction)方法来为GET请求创建映射;和POST(String, HandlerFunction)用于POST。

除了基于HTTP方法的映射之外，路由构建器还提供了一种在映射到请求时引入额外谓词的方法。对于每个HTTP方法，都有一个以RequestPredicate作为参数的重载变量，但是可以表示其他约束。

#### Predicates

您可以编写自己的RequestPredicate，但是RequestPredicates实用程序类提供了基于请求路径、HTTP方法、内容类型等的常用实现。以下示例使用请求谓词基于Accept报头创建约束:

```java
RouterFunction<ServerResponse> route = RouterFunctions.route()
    .GET("/hello-world", accept(MediaType.TEXT_PLAIN),
        request -> ServerResponse.ok().bodyValue("Hello World")).build();
```

你可以使用以下方法组合多个请求谓词:

- `RequestPredicate.and(RequestPredicate)` — both must match.
- `RequestPredicate.or(RequestPredicate)` — either can match.

requestpredicate中的许多谓词都是由组合而成的。例如，requestpredicate . get (String)由requestpredicate .method(HttpMethod)和requestpredicate .path(String)组成。上面显示的示例还使用了两个请求谓词，因为构建器使用了RequestPredicates.GET在内部，并与accept谓词组合。

#### Routes

路由器函数按顺序计算:如果第一条路由不匹配，则计算第二条路由，依此类推。因此，在通用路由之前声明更具体的路由是有意义的。当将路由器函数注册为Spring bean时，这一点也很重要，稍后将对此进行描述。请注意，***这种行为不同于基于注解的编程模型，后者自动选择“最特定的”控制器方法。***

当使用路由器函数构建器时，所有已定义的路由都被组成一个RouterFunction，由build()返回。还有其他的方法来组成多个路由器功能在一起:

- `add(RouterFunction)` on the `RouterFunctions.route()` builder
- `RouterFunction.and(RouterFunction)`
- `RouterFunction.andRoute(RequestPredicate, HandlerFunction)` — shortcut for `RouterFunction.and()` with nested `RouterFunctions.route()`.

下面的例子展示了四条路线的组成:

```java
import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.RequestPredicates.*;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction<ServerResponse> otherRoute = ...

RouterFunction<ServerResponse> route = route()
    .GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson) 
    .GET("/person", accept(APPLICATION_JSON), handler::listPeople) 
    .POST("/person", handler::createPerson) 
    .add(otherRoute) 
    .build();
```

#### 嵌套Routes(谓词共享)

一组路由器函数具有共享谓词(例如共享路径)是很常见的。在上面的示例中，共享谓词将是匹配/person的路径谓词，由三个路由使用。在使用注释时，可以通过使用映射到/person的类型级@RequestMapping注释来删除这种重复。在WebFlux.Fn，路径谓词可以通过路由器函数构建器上的path方法共享。例如，上面的例子的最后几行可以通过使用嵌套路由改进如下:

```java
RouterFunction<ServerResponse> route = route()
    // path 被共享
    .path("/person", builder -> builder 
        .GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)
        .GET(accept(APPLICATION_JSON), handler::listPeople)
        .POST("/person", handler::createPerson))
    .build();
```

虽然基于路径的嵌套是最常见的，但您可以通过使用构建器上的nest方法嵌套任何类型的谓词。上面的谓词仍然以共享的Accept-header谓词的形式包含一些重复。我们可以通过使用nest方法和accept来进一步改进:

```java
RouterFunction<ServerResponse> route = route()
    .path("/person", b1 -> b1
          // 继续优化 共享头信息
        .nest(accept(APPLICATION_JSON), b2 -> b2
            .GET("/{id}", handler::getPerson)
            .GET(handler::listPeople))
        .POST("/person", handler::createPerson))
    .build();
```

### Running a Server

如何在HTTP服务器中运行路由器功能?一个简单的选项是使用以下方法将一个路由器函数转换为HttpHandler:

- `RouterFunctions.toHttpHandler(RouterFunction)`
- `RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)`

然后，通过遵循HttpHandler获取特定于服务器的指令，您可以将返回的HttpHandler与许多服务器适配器一起使用。

一个更典型的选项(也被Spring Boot使用)是通过WebFlux Config运行一个基于dispatcherhandler的设置，它使用Spring配置来声明处理请求所需的组件。WebFlux Java配置声明了以下基础架构组件来支持功能端点:

- `RouterFunctionMapping`: 检测一个或多个Spring配置中的 RouterFunction<?> bean，订购它们，并通过RouterFunction.andOther组合它们。并将请求路由到合成的RouterFunction。
- `HandlerFunctionAdapter`: 一个简单的适配器，允许DispatcherHandler调用映射到请求的HandlerFunction。
- `ServerResponseResultHandler`: 通过调用ServerResponse的writeTo方法来处理HandlerFunction调用的结果。

前面的组件让功能性端点适合DispatcherHandler请求处理生命周期，并且(可能)与带注释的控制器(如果声明了任何控制器)一起运行。这也是Spring Boot WebFlux启动器如何启用功能性端点。

下面的例子展示了一个WebFlux Java配置(参见DispatcherHandler如何运行它):

```java
@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Bean
    public RouterFunction<?> routerFunctionA() {
        // ...
    }

    @Bean
    public RouterFunction<?> routerFunctionB() {
        // ...
    }

    // ...

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        // configure message conversion...
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // configure CORS...
    }

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        // configure view resolution for HTML rendering...
    }
}
```

### Filtering Handler Functions

您可以通过使用路由函数构建器上的before、after或filter方法来筛选处理程序函数。使用注释，您可以通过使用@ControllerAdvice、ServletFilter或两者来实现类似的功能。该过滤器将应用于由构建器构建的所有路由。这意味着在嵌套路由中定义的过滤器不适用于“顶级”路由。例如，考虑以下例子:

```java
RouterFunction<ServerResponse> route = route()
    .path("/person", b1 -> b1
        .nest(accept(APPLICATION_JSON), b2 -> b2
            .GET("/{id}", handler::getPerson)
            .GET(handler::listPeople)
              // 添加自定义请求头的before过滤器只应用于两个GET路由。
            .before(request -> ServerRequest.from(request) 
                .header("X-RequestHeader", "Value")
                .build()))
        .POST("/person", handler::createPerson))
    // 记录响应的after过滤器应用于所有路由，包括嵌套的路由。
    .after((request, response) -> logResponse(response)) 
    .build();
```

路由器构建器上的filter方法接受HandlerFilterFunction:该函数接受ServerRequest和HandlerFunction并返回ServerResponse。handler函数参数表示链中的下一个元素。这通常是路由到的处理程序，但如果应用了多个过滤器，它也可以是另一个过滤器。

现在我们可以向路由添加一个简单的安全过滤器，假设我们有一个SecurityManager，它可以决定是否允许特定的路径。下面的例子展示了如何做到这一点:

```java
SecurityManager securityManager = ...

RouterFunction<ServerResponse> route = route()
    .path("/person", b1 -> b1
        .nest(accept(APPLICATION_JSON), b2 -> b2
            .GET("/{id}", handler::getPerson)
            .GET(handler::listPeople))
        .POST("/person", handler::createPerson))
    .filter((request, next) -> {
        if (securityManager.allowAccessTo(request.path())) {
            return next.handle(request);
        }
        else {
            return ServerResponse.status(UNAUTHORIZED).build();
        }
    })
    .build();
```

前面的示例演示了调用next.handle(ServerRequest)是可选的。我们只在允许访问时才让handler函数运行。

除了在路由器函数生成器中使用filter方法之外，还可以通过RouterFunction.filter(HandlerFilterFunction)将filter应用到现有的路由器函数中。

> 功能端点的CORS支持是通过专用的CorsWebFilter提供的。

## 6 URI Links

**组件**

```java
UriComponents uriComponents = UriComponentsBuilder
    // 使用URI模板的静态工厂方法。
        .fromUriString("https://example.com/hotels/{hotel}")  
    // 	Add or replace URI components.
        .queryParam("q", "{q}")  
    // 请求对URI模板和URI变量进行编码
        .encode() 
    // Build a UriComponents.
        .build(); 
// 展开变量并获取URI。
URI uri = uriComponents.expand("Westin", "123").toUri();  
```

上面的例子可以合并到一个链中，并使用buildandexexpand进行缩短，如下面的例子所示:

```java
URI uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")
        .queryParam("q", "{q}")
        .encode()
        .buildAndExpand("Westin", "123")
        .toUri();
```

你可以直接转到一个URI(这意味着编码)来进一步缩短它，如下面的例子所示:

```java
URI uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")
        .queryParam("q", "{q}")
        .build("Westin", "123");
```

你可以用一个完整的URI模板进一步缩短它，如下面的例子所示:

```java
URI uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}?q={q}")
        .build("Westin", "123");
```

**UriBuilderFactory**

UriComponentsBuilder实现UriBuilder。你可以用一个UriBuilderFactory创建一个UriBuilder。UriBuilderFactory和UriBuilder一起提供了一种可插入的机制，以基于共享配置(如基URL、编码首选项和其他细节)从URI模板构建URI。

你可以用一个UriBuilderFactory配置RestTemplate和WebClient来定制uri的准备。DefaultUriBuilderFactory是urbuilderfactory的默认实现，它在内部使用UriComponentsBuilder并公开共享的配置选项。

下面的示例展示了如何配置RestTemplate:

```java
// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = "https://example.org";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(factory);
```

配置WebClient的示例如下:

```java
// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = "https://example.org";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

WebClient client = WebClient.builder().uriBuilderFactory(factory).build();
```

此外，您还可以直接使用DefaultUriBuilderFactory。它类似于使用UriComponentsBuilder，但不是静态工厂方法，它是一个保存配置和首选项的实际实例，如下例所示:

```java
String baseUrl = "https://example.com";
DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);

URI uri = uriBuilderFactory.uriString("/hotels/{hotel}")
        .queryParam("q", "{q}")
        .build("Westin", "123");
```

## 7 CORS

Spring WebFlux允许你处理CORS((Cross-Origin Resource Sharing:跨源资源共享)。

### `@CrossOrigin`

@CrossOrigin注释允许对带注释的控制器方法进行跨源请求，示例如下:

```java
@RestController
@RequestMapping("/account")
public class AccountController {

    @CrossOrigin
    @GetMapping("/{id}")
    public Mono<Account> retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public Mono<Void> remove(@PathVariable Long id) {
        // ...
    }
}
```

默认的值, `@CrossOrigin` allows:

- All origins.
- All headers.
- All HTTP methods to which the controller method is mapped.

`maxAge` is set to 30 minutes.

在类级别上也支持@CrossOrigin，并被所有方法继承。下面的示例指定一个域并将maxAge设置为一个小时:

```java
@CrossOrigin(origins = "https://domain2.com", maxAge = 3600)
@RestController
@RequestMapping("/account")
public class AccountController {

    @GetMapping("/{id}")
    public Mono<Account> retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public Mono<Void> remove(@PathVariable Long id) {
        // ...
    }
}
```

你可以在类级和方法级使用@CrossOrigin，如下面的例子所示:

```java
@CrossOrigin(maxAge = 3600) 
@RestController
@RequestMapping("/account")
public class AccountController {

    @CrossOrigin("https://domain2.com") 
    @GetMapping("/{id}")
    public Mono<Account> retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public Mono<Void> remove(@PathVariable Long id) {
        // ...
    }
}
```

### 全局配置

```java
@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {

        registry.addMapping("/api/**")
            .allowedOrigins("https://domain2.com")
            .allowedMethods("PUT", "DELETE")
            .allowedHeaders("header1", "header2", "header3")
            .exposedHeaders("header1", "header2")
            .allowCredentials(true).maxAge(3600);

        // Add more mappings...
    }
}
```

### CORS `WebFilter`

```java
@Bean
CorsWebFilter corsFilter() {

    CorsConfiguration config = new CorsConfiguration();

    // Possibly...
    // config.applyPermitDefaultValues()

    config.setAllowCredentials(true);
    config.addAllowedOrigin("https://domain1.com");
    config.addAllowedHeader("*");
    config.addAllowedMethod("*");

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", config);

    return new CorsWebFilter(source);
}
```

## Web Security

……

## View Technologies

……

## WebFlux Config

WebFlux Java配置声明了处理带有带注释的控制器或功能性端点的请求所需的组件，并提供了定制配置的API。这意味着您不需要理解Java配置创建的底层bean。但是，如果你想理解它们，你可以在WebFluxConfigurationSupport中看到它们，或者在Special Bean类型中阅读更多关于它们的内容。

对于配置API中没有的更高级的自定义，您可以通过advanced configuration Mode获得对配置的完全控制。

### Enabling WebFlux Config

你可以在你的Java配置中使用@EnableWebFlux注解，如下所示:

```java
@Configuration
@EnableWebFlux
public class WebConfig {
}
```

### WebFlux config API

在您的Java配置中，您可以实现WebFluxConfigurer接口，如下面的示例所示:

```java
@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    // Implement configuration methods...
}
```

### Conversion, formatting

默认情况下，安装了各种数字和日期类型的格式化程序，并支持通过@NumberFormat和@DateTimeFormat对字段进行自定义。

要在Java配置中注册自定义格式器和转换器，请使用以下方法:

```java
@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        // ...
    }

}
```

默认情况下，在解析和格式化日期值时，Spring WebFlux会考虑请求的区域设置。这适用于日期表示为带有“输入”表单字段的字符串的表单。对于“date”和“time”字段，浏览器使用HTML规范中定义的固定格式。对于这种情况，日期和时间的格式可以自定义如下:

```java
@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setUseIsoFormat(true);
        registrar.registerFormatters(registry);
    }
}
```

### Validation

默认情况下，如果类路径上存在Bean验证(例如Hibernate验证器)，LocalValidatorFactoryBean将注册为一个全局验证器，用于@Controller方法参数上的@Valid和@Validated。

在您的Java配置中，您可以自定义全局Validator实例，如下面的示例所示:

```java
@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public Validator getValidator(); {
        // ...
    }

}
```

注意，你也可以在本地注册Validator实现，如下面的例子所示:

```java
@Controller
public class MyController {

    @InitBinder
    protected void initBinder(WebDataBinder binder) {
        binder.addValidators(new FooValidator());
    }

}
```

### webservicec

```java
@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public WebSocketService getWebSocketService() {
        TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();
        strategy.setMaxSessionIdleTimeout(0L);
        return new HandshakeWebSocketService(strategy);
    }
}
```

